a["{\"msg\":\"result\",\"id\":\"2502\",\"result\":{\"_id\":\"dZQ2GvzoJRaNhvs8B\",\"author\":\"Luis Pereira\",\"authorId\":\"aEm3Wvj2rFYRL8Lrb\",\"code\":\"def max_consec(lst):\\n\\t\",\"difficulty\":5,\"quality\":0,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"s2W3rbxLydr2fKujg\",\"instructions\":\"This challenge is a harder version of a [previous challenge](https://edabit.com/challenge/9v34qtFufkqPmzeDu), but now with an additional efficiency requirement (see the \\\"The catch\\\" discussion below). We first recall the problem:\\n\\nGiven a list of integers, find the length of the longest range of consecutive integers that are contained in the sorted version of the list.\\n\\nHere's an illustrative example. Consider the list:\\n\\n```\\n[4, 9, 10, 5, 17, 3, 8, 11, 1, 12, 18, 20]\\n```\\n\\n... which, after sorting, becomes:\\n\\n```\\n[1, 2, 4, 5, 8, 9, 10, 11, 12, 17, 18, 20]\\n```\\n\\nThe longest consecutive subsequence is clearly `[8, 9, 10, 11, 12]`, which has length `5`.\\n\\n### The Catch\\nLooking at the problem, a natural way to approach it is to first sort the list. However, the lists in the tests have been designed so that sorting is a little too slow (more details on the notes below).\\n\\nThus, you will probably want a faster solution that does not rely on sorting.\\n\\n### Examples\\n```\\nmax_consec([4, 9, 10, 5, 17, 3, 8, 11, 1, 12, 18, 20]) ➞ 5\\n# After sorting list becomes [1, 2, 4, 5, 8, 9, 10, 11, 12, 17, 18, 20]\\n# Longest consecutive subsequence is [8, 9, 10, 11, 12], which has length 5\\n\\nmax_consec([13, 3, 8, 5, 5, 2, 13, 6, 14, 2, 11, 4, 10, 8, 1, 9]) ➞ 6\\n# After sorting get [1, 2, 2, 3, 4, 5, 5, 6, 8, 8, 9, 10, 11, 13, 13, 14]\\n# Longest consecutive subsequence is [1, 2, 3, 4, 5, 6], which has length 6\\n```\\n\\n### Notes\\n- The intended solution to this challenge runs in linear `O(n)` time, and I think that a linear solution will be needed to pass the tests.\\n- It is well known that sorting a list of length `n` can be done in `O(n log n)` time. However, this is a worst-case scenario, as sorting is often faster if the list already has some order to it. As such, to make sorting unviable, the tests start by generating a very large (`2**20` elements) random list, then inserting consecutive sequences into that list.\\n- Generating such a massive list takes a fair amount of the available time, with some variation (6~7 seconds). As such, the two rounds of tests (i.e. the two times that your function is run) are allotted a total run time of 5s. For reference, the run times for my solution vary in the `3.8s-4.2s` range.\\n- I apologize in advance for the short time margin for the tests. As it turns out, even for `n = 2**20` one still has `log n = 20`, so sorting runs in about `O(20n)`, still making it pretty hard to beat (and more so because, from what I hear, sorting in Python runs using C code). As such, even for such a large list, my linear `O(n)` solution only beats sorting by a factor of about `1.5~1.7`. This discrepancy could be made larger for even larger lists, but such lists can not be created within the 12s time limit for the server.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"from random import randint\\nfrom time import perf_counter\\n\\nexpnt = 350\\nlow_bnd, high_bnd = 2**expnt, 2**(expnt+1) + 2**(expnt//2)\\nlist_size = 2**20+2**18\\n\\nstart = perf_counter()\\nbase_list = [randint(low_bnd, high_bnd) for _ in range(list_size)]\\nprint('time to create the base list = {:.3f} sec'.format(perf_counter() - start))\\nmehtime = perf_counter() - start\\n\\ntest_list_time = 0\\ntest_time = 0\\n\\nfor rnd in range(2):\\n    print(' ')\\n    print('Round {}:'.format(rnd+1))\\n    start = perf_counter()\\n    anchor_cnt = randint(3,7)\\n    anchors = [randint(low_bnd, high_bnd) for _ in range(anchor_cnt)]\\n    anchors = [a for i,a in enumerate(anchors) if all(abs(a-aa)>1000 for aa in anchors[:i])] \\n    anchor_cnt = len(anchors)\\n\\n    seq_lengths = [randint(10,150) for _ in range(anchor_cnt)]\\n    forbidden = [a-1 for a in anchors] + [a+seq_lengths[i] for i,a in enumerate(anchors)]\\n\\n    test_list = [n for n in base_list if n not in forbidden]\\n\\n    for i in range(anchor_cnt):\\n        for j in range(seq_lengths[i]):\\n            test_list.insert(randint(0,list_size), anchors[i]+j)\\t\\t\\t\\t\\n\\t\\n    print('time to modify test list in Round {} = {:.3f} sec'.format(rnd+1,perf_counter() - start))\\n    test_list_time += perf_counter() - start\\n\\n    start = perf_counter()\\n    Test.assert_equals(max_consec(test_list), max(seq_lengths))\\n    print('time function spent on Round {} = {:.3f} sec'.format(rnd+1, perf_counter() - start))\\n    test_time += perf_counter() - start\\n\\nprint(' ')\\nprint('Cumulative times')\\nprint('total time to modify test lists = {:.3f} sec'.format(test_list_time))\\nprint('total test time spent by function = {:.3f} sec'.format(test_time))\\n\\nTest.assert_equals(test_time < 5, True)\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,5],\"quality\":[],\"rators\":[\"eHcgvkTGsH7ZziqBo\",\"iS5BrkGLzJyPK7nKt\"],\"total\":5},\"flags\":0},\"summary\":\"This challenge is a harder version of a previous challenge, but now with an additional efficiency requirement (see the \\\"The catch\\\" discussion below). We first recall the problem:\\n\\nGiven a list of integers, find the length of the longest range of consecutive integers that are contained in the sorted version of the list.\\n\\nHere's an illustrative example. Consider\",\"tags\":[\"arrays\",\"algorithms\",\"numbers\"],\"timestamp\":{\"$date\":1599618919997},\"title\":\"Longest Range in the List (Hardcore Version)\",\"family\":[{\"_id\":\"dZQ2GvzoJRaNhvs8B\",\"language\":\"python3\"}]}}"]