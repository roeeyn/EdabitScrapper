a["{\"msg\":\"result\",\"id\":\"2474\",\"result\":{\"_id\":\"LQMKcSTw9swdWFMR7\",\"author\":\"RandyWaterhouse\",\"authorId\":\"AraFx3EGW7PsqMPWt\",\"code\":\"class FourVector:\\n\\t\",\"difficulty\":4.75,\"quality\":0,\"editorId\":\"AraFx3EGW7PsqMPWt\",\"familyId\":\"wm5KMH7eawEQD5x4M\",\"instructions\":\"In this challenge, we extend the `FourVector` class we created in the [first](https://edabit.com/challenge/cPxexgGxmCMi4kas8) and [second](https://edabit.com/challenge/PgivAghJdMY7HM2pK) installment of the `FourVector` collection. We will now add Lorentz transformations namely \\\"Pure Rotations\\\" and \\\"Pure Boosts\\\". For details on this operation, please refer to the Wiki page linked in the **Resources**.\\n\\nSo, please add the following features to the class `FourVector`:\\n\\n- A helper method `KroneckerDelta` which takes two integers (say `i` and `j`) and returns `1` if i=j and `0` otherwise.\\n- A helper method `LeviCivitaSymbol` which takes three integers (say `i`, `j` and `k`) and returns `1` if `(i,j,k)` is an even permutation of `(1,2,3)` (i.e.  `(i,j,k)` is  `(1,2,3)`,  `(2,3,1)` or  `(3,1,2)`), `-1`if `(i,j,k)` is an odd permutation of `(1,2,3)` (i.e.  `(i,j,k)` is  `(1,3,2)`,  `(2,1,3)` or  `(3,2,1)`) and `0` otherwise (i.e. if i=j or i=k or j=k).\\n- A method `PureRotation` which takes a 3D-vector and an angle (in degrees) as arguments. It should perform a pure rotation (no boost) as specified [here](https://en.wikipedia.org/wiki/Four-vector#Pure_rotations_about_an_arbitrary_axis). In the test cases, the 3D-vector is not always a unit vector, so please normalize it. The return value is a new Four Vector, i.e. the original FV is not changed.\\n- A method `PureBoost` which takes a 3D-vector as an argument representing a 3-velocity between the two reference frames as specified [here](https://en.wikipedia.org/wiki/Four-vector#Pure_boosts_in_an_arbitrary_direction). It should perform a pure boost (no rotation by the 3-velocity passed as argument). The return value is a new Four Vector, i.e. the original FV is not changed. Please use a value of `299792458` for the speed of light (in meters per second).\\n\\n### Examples\\n```\\nu1 = FourVector([0, 1, 0, 0])\\nu1.KroneckerDelta(1, 1) ➞ 1\\nu1.KroneckerDelta(1, 2) ➞ 0\\nu1.LeviCivitaSymbol(1, 3, 2) ➞ -1\\nu1.LeviCivitaSymbol(1, 3, 1) ➞ 0\\nu1.PureRotation([0, 1, 0], 90) ➞ FourVector([0.0, 0.0, 0.0, -1.0])\\nc = 299792458.0\\nu1.PureBoost([c/100., 0, 0]) ➞ FourVector([-0.010000500037503126, 1.0000500037503126, 0.0, 0.0])\\n```\\n\\n### Notes\\nPlease save your `FourVector` class for later use, we will add new features in upcoming challenges in this series!\\nYou may assume valid test cases (e.g. no boost with `v=[0,0,0]`).\",\"isFree\":false,\"isHidden\":false,\"lab\":\"import random\\nimport math\\n\\nu0 = FourVector([1, 0, 0, 0])\\nu1 = FourVector([0, 1, 0, 0])\\nu2 = FourVector([0, 0, 1, 0])\\nu3 = FourVector([0, 0, 0, 1])\\nv1 = FourVector([1, 1, 1, 0])\\nv5 = FourVector([-1, 37, 55, -108])\\nv6 = FourVector([0.5, 1.0, -2.0, 10.0])\\nv7 = FourVector([-0.25, 1.2, -2.7, 33.3])\\nv8 = FourVector([-1, 2, -3, 4])\\n\\n# KroneckerDelta:\\nTest.assert_equals(u1.KroneckerDelta(1, 1), 1)\\nTest.assert_equals(u1.KroneckerDelta(1, 2), 0)\\nTest.assert_equals(u1.KroneckerDelta(1, 3), 0)\\nTest.assert_equals(u1.KroneckerDelta(3, 1), 0)\\nTest.assert_equals(u1.KroneckerDelta(3, 2), 0)\\nTest.assert_equals(u1.KroneckerDelta(2, 2), 1)\\n\\n# LeviCivitaSymbol:\\nTest.assert_equals(u1.LeviCivitaSymbol(1, 2, 3), 1)\\nTest.assert_equals(u1.LeviCivitaSymbol(2, 3, 1), 1)\\nTest.assert_equals(u1.LeviCivitaSymbol(3, 1, 2), 1)\\nTest.assert_equals(u1.LeviCivitaSymbol(1, 3, 2), -1)\\nTest.assert_equals(u1.LeviCivitaSymbol(2, 1, 3), -1)\\nTest.assert_equals(u1.LeviCivitaSymbol(3, 2, 1), -1)\\nTest.assert_equals(u1.LeviCivitaSymbol(1, 1, 2), 0)\\nTest.assert_equals(u1.LeviCivitaSymbol(2, 2, 2), 0)\\nTest.assert_equals(u1.LeviCivitaSymbol(3, 1, 3), 0)\\n\\n# Pure Rotations:\\neps = 1e-6\\ntest_data = [[u1, [1, 0, 0], 90, [0.0, 1.0, 0.0, 0.0]],\\n             [u1, [0, 1, 0], 90, [0.0, 0.0, 0.0, -1.0]],\\n             [u1, [0, 0, 1], 90, [0.0, 0.0, 1.0, 0.0]],\\n             [u1, [1, 1, 0], 90, [0.0, 0.5, 0.5, -0.7071067811865475]],\\n             [u1, [0, 1, 1], 90, [0.0, 0.0, 0.7071067811865475, -0.7071067811865475]],\\n             [u1, [1, 0, 1], 90, [0.0, 0.5, 0.7071067811865475, 0.5]],\\n             [u1.PureRotation([1, 1, 1], 45), [1, 1, 1], -45, u1.GetComponents()]]\\nfor vec1, unit_vec, angle, comp1 in test_data:\\n    vec2 = vec1.PureRotation(unit_vec, angle)\\n    comp2 = vec2.GetComponents()\\n    Test.assert_equals(sum([abs(comp1[i] - comp2[i]) for i in range(4)]) < eps, True)\\n\\nfor _ in range(10):\\n    angle = random.randint(-359, 359)\\n    c1 = random.randint(-10, 10)\\n    c2 = random.randint(-10, 10)\\n    c3 = random.randint(-10, 10)\\n    if c1 == c2 == c3 == 0:\\n        continue\\n    l = math.sqrt(c1**2 + c2**2 + c3**2)\\n    unit_vec = [c1 / l, c2 / l, c3 / l]\\n    vec1 = random.choice([v5, v6, v7, v8])\\n    len1 = vec1.GetLength()\\n    len2 = vec1.PureRotation(unit_vec, angle).GetLength()\\n    Test.assert_equals(abs(len1 - len2) < eps, True, \\\"Rotations change lengths: \\\"\\n                       + str(vec1) + \\\" \\\" + str(unit_vec) + \\\" \\\" + str(angle) + \\\" \\\" + \\\\\\n                       str(vec1.PureRotation(unit_vec, angle)) + \\\" \\\" + str(len1) + \\\" \\\" + \\\\\\n                       str(len2))\\n\\n# Pure Boosts:\\nc = 299792458.       # speed of light in m/s\\ntest_data = [[u1, [c/100., 0, 0], [-0.010000500037503126, 1.0000500037503126, 0.0, 0.0]],\\n             [u3, [c/10., 0, 0], [0.0, 0.0, 0.0, 1.0]],\\n             [v5, [c/10., c/5., c/5.], [6.184880536659318, 36.73464473547082, 54.46928947094164, -108.53071052905835]],\\n             [v6, [0., 0.999*c, 0.], [55.87094756123916, 1.0, -55.90449696930236, 10.0]],\\n             [v7, [0., 0, 0.99999999*c], [-237234.324112771, 1.2, -2.7, 237234.32644975893]],\\n             [v8, [c/10., c/10., c/10.], [-1.3199500146737049, 2.1168807816469806, -2.8831192183530185, 4.116880781646981]],\\n             [v5+v7, [0, c/2., 0.], [-31.638794751591494, 38.2, 61.112525993721896, -74.7]]]\\nfor vec1, v, comp1 in test_data:\\n    vec2 = vec1.PureBoost(v)\\n    comp2 = vec2.GetComponents()\\n    Test.assert_equals(sum([abs(comp1[i] - comp2[i]) for i in range(4)]) < eps, True)\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,3,5,5,4,5,5],\"quality\":[],\"rators\":[\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"hRAd998MG8Jzdpxj6\",\"fSQSHjW3e72MrWxbD\",\"38cEoB5NrMG6ompwH\",\"eMuCpJ2spXWkJjWNz\",\"yjtdwc2AC4jA2RWtn\"],\"total\":8},\"flags\":1},\"summary\":\"In this challenge, we extend the FourVector class we created in the first and second installment of the FourVector collection. We will now add Lorentz transformations namely \\\"Pure Rotations\\\" and \\\"Pure Boosts\\\". For details on this operation, please refer to the Wiki page linked in the Resources.\\n\\nSo, please add the following features to the class FourVector:\\n\\nA\",\"tags\":[\"physics\",\"math\",\"classes\"],\"timestamp\":{\"$date\":1600322537135},\"title\":\"Four Vectors Part 3: Lorentz Transformations\",\"family\":[{\"_id\":\"LQMKcSTw9swdWFMR7\",\"language\":\"python3\"}]}}"]