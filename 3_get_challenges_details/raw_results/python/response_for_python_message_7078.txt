a["{\"msg\":\"result\",\"id\":\"2245\",\"result\":{\"_id\":\"xsBX7vABGoL9m8Z4e\",\"archived\":false,\"author\":\"kochug\",\"authorId\":\"vQEmjTRgmdGNYB7yk\",\"code\":\"def sync_subs(subtitles, timeIncrement):\\n\\t\",\"difficulty\":3.5,\"familyId\":\"giEkhyDiT2vX2y9bv\",\"instructions\":\"Create a function that will increment every time format found in a string (for example `00:42:33,120`) by a specific time (for example `00:00:30,550`). The result between the examples is `00:43:03,670`.\\n\\n### Rules\\n- The function must take 2 arguments: a string from where to search time format and a string that respects the format `hours:minutes:seconds,milliseconds`.\\n- The function must return a string identical to the first argument but with all time format incremented with the second argument time format.\\n- If the second argument does not respect the given time format (for example `00:00:00` or `0:0:0,000`), you must return \\\"There is a problem with the second argument\\\".\\n\\n### Examples\\n```\\nsync_subs(\\\"708\\n00:44:50,006 --> 00:44:53,007\\nHi.\\\", \\\"00:03:30,550\\\")\\n➞\\n\\\"708\\n00:45:20,556 --> 00:45:23,557\\nHi.\\\"\\n\\nsync_subs(\\\"179\\n00:12:52,766 --> 00:12:55,900\\n[Door rattling]\\\", \\\"00:11:11,111\\\")\\n➞\\n\\\"179\\n00:24:04,011 --> 00:24:07,011\\n[Door rattling]\\\"\\n\\nsync_subs(\\\"188\\n00:13:37,243 --> 00:13:39,744\\n30 minutes.\\nEveryone's ready.\\n189\\n00:13:39,779 --> 00:13:43,548\\n\\n\\\", \\\"01:00:51,111\\\")\\n➞\\n\\\"188\\n02:06:28,000 --> 02:06:30,000\\n30 minutes.\\nEveryone's ready.\\n189\\n02:06:30,000 --> 02:06:34,000\\\"\\n```\\n\\n### Notes\\nYou don't need to worry about a time format being wrong in the first string like `00:13:79,779` or `00:13:39,79` because there won't be any mistake in it.\",\"lab\":\"Test.assert_equals(sync_subs(\\n\\\"\\\"\\\"708\\n00:44:50,006 --> 00:44:53,007\\nPeople are taking this festival extremely seriously.\\\"\\\"\\\", \\\"00:03:30,550\\\"),\\n\\\"\\\"\\\"708\\n00:48:20,556 --> 00:48:23,557\\nPeople are taking this festival extremely seriously.\\\"\\\"\\\")\\n\\nTest.assert_equals(sync_subs(\\n\\\"\\\"\\\"729\\n00:45:55,704 --> 00:45:59,506\\nSo we don't have to wait for it.\\\"\\\"\\\", \\\"00:00:00,000\\\"),\\n\\\"\\\"\\\"729\\n00:45:55,704 --> 00:45:59,506\\nSo we don't have to wait for it.\\\"\\\"\\\")\\n\\nTest.assert_equals(sync_subs(\\n\\\"\\\"\\\"735\\n00:46:24,967 --> 00:46:27,701\\nWe've already won.\\n736\\n00:46:27,736 --> 00:46:30,637\\n[Crowd cheers]\\\"\\\"\\\", \\\"01:21:00,211\\\"),\\n\\\"\\\"\\\"735\\n02:07:25,178 --> 02:07:27,912\\nWe've already won.\\n736\\n02:07:27,947 --> 02:07:30,848\\n[Crowd cheers]\\\"\\\"\\\")\\n\\nTest.assert_equals(sync_subs(\\n\\\"\\\"\\\"722\\n00:45:34,483 --> 00:45:36,917\\nMy mercy...\\\"\\\"\\\", \\\"00:60:09,010\\\"),\\n\\\"There is a problem with the second argument\\\")\\n\\nTest.assert_equals(sync_subs(\\n\\\"\\\"\\\"722\\n00:45:34,483 --> 00:45:36,917\\nMy mercy...\\\"\\\"\\\", \\\"00:00:09.000\\\"),\\n\\\"There is a problem with the second argument\\\")\",\"language\":\"python3\",\"summary\":\"Create a function that will increment every time format found in a string (for example 00:42:33,120) by a specific time (for example 00:00:30,550). The result between the examples is 00:43:03,670.\\n\\nRules\\nThe function must take 2 arguments: a string from where to search time format and a string that respects the format hours:minutes:seconds,milliseconds.\\nThe fu\",\"tags\":[\"algorithms\",\"regex\",\"strings\",\"formatting\"],\"timestamp\":{\"$date\":1524387192138},\"title\":\"Synchronize the Subtitles\",\"stats\":{\"completed\":{\"total\":50,\"ratings\":[2,2,2,2,2,1,2,4,3,3,3,3,2,3,3,3,3,4,5,3,4,4,4,4,3,5,5,5,5,3,4,5,5,5,0,5,4,5,4,3,5,3,5,2,3,5,5,3],\"rators\":[\"vQEmjTRgmdGNYB7yk\",\"tzHQmfmDbNJgqbeLx\",\"6fJpRpAgiWD5zX9qB\",\"3mtD7DxrAgDMcxWKt\",\"KHLJJM4grqF6xmo5t\",\"m2iiZZHTpzHcEKJMn\",\"pdcaC4fEtsubBz4Wo\",\"tAF9Gf6PiGogbZuWs\",\"RsX6W2ddWM8ajHzss\",\"uJ5A3zjLi9iN5eeXX\",\"n9PZCXcWTygjaDsXs\",\"8JyqsSbN2FJXPr3cw\",\"T3ZAuoMrJjvZwN55B\",\"yZvzB3qFb8pkHy4dg\",\"P59rek6gvwTzHvRYa\",\"AYaEkTWLMmfzpwejr\",\"BFNm9gacwba9KyLFW\",\"gb9rvGus2Jv7bjZSs\",\"HqmxnQJM66Y57twhn\",\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"AasGs8AeX9Lcb9xJn\",\"vjxLM6QpR3ZiduN9E\",\"aYuKFKSE7oKvBGHKr\",\"eHcgvkTGsH7ZziqBo\",\"vTfyrr4pGddp8rbXc\",\"DwetpbChQM4r6Gwah\",\"Nua6T3dBurBy3Qfg9\",\"B4jPYeyvixcfEZknA\",\"zQ8ioTQfJP8zjMnqg\",\"586FdBhazpwJfnRYR\",\"5H9MNfC4DPwxbakTf\",\"ZNnsMeNkdDhHjSrZb\",\"R4SjTgDnpigJYDLyL\",\"xn7uGNKeAwPEkP9oA\",\"4fhjJBvLBWh6QeSih\",\"PbFZKHNGGqEacTSQS\",\"h4x2jaMdj5aQZbW5g\",\"iS5BrkGLzJyPK7nKt\",\"Cc2Cgj4MWXZxsTooC\",\"yjtdwc2AC4jA2RWtn\",\"8sNv5PTHa7XQ8bNqR\",\"JKb5rhL6DKcCAypF9\",\"2PufnQcsHsfymufX3\",\"gJYuGdkXEWWmGRLzu\",\"s5M5RvgqR9BhB9JoC\"],\"quality\":[2,5]},\"complaints\":{\"total\":0,\"reasons\":[],\"skippers\":[\"vQEmjTRgmdGNYB7yk\"]},\"instructions\":{\"score\":-32,\"voters\":[\"GRZzKCbeb4xKHFCrZ\",\"P3Rgvwe9huA23S9fM\",\"5FbXfTCwHopDAtvJA\",\"BvcqHPxsT26HWsL5e\",\"tAF9Gf6PiGogbZuWs\",\"LBHrRYLgzn7Q7FibL\"]},\"tests\":{\"score\":-21.7,\"voters\":[\"tAF9Gf6PiGogbZuWs\"]},\"flags\":0},\"editorId\":\"BkPgkDQGHm66X4Qai\",\"isHidden\":false,\"quality\":3.5,\"family\":[{\"_id\":\"H4of8EdxS98ikEaZd\",\"language\":\"javascript\"},{\"_id\":\"xsBX7vABGoL9m8Z4e\",\"language\":\"python3\"}]}}"]