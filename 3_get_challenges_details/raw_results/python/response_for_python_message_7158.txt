a["{\"msg\":\"result\",\"id\":\"2285\",\"result\":{\"_id\":\"GTnW4bQAZQ38oHuyi\",\"author\":\"Deep Xavier\",\"authorId\":\"a777e8chPvJkY3tKa\",\"code\":\"def bitwise_one_zero(lst):\\n\\t# your recursive solution here\\n\\treturn bitwise_one_zero(lst)\",\"difficulty\":3.5833333333333335,\"familyId\":\"J2LKrRdbmCjQS94dd\",\"instructions\":\"Write a function that returns the smallest integer in a list with its corresponding index and its parity. Although these tasks can be equivocally achievable with the use of some built-in and list functions, the purpose and intent of this challenge is for you to solve it recursively.\\n\\n**_Output Structure_**:\\n```\\n{\\\"@index \\\" + index_of_smallest: smallest_integer, \\\"parity\\\": \\\"odd|even\\\"}\\n```\\n\\n### Examples\\n```\\nbitwise_one_zero([107, 19, -18, -79, 36, 23, 97]) ➞ {\\\"@index 3\\\": -79, \\\"parity\\\": \\\"odd\\\"}\\n\\nbitwise_one_zero([31, 7, 2, 13, 7, 9, 10, 13]) ➞ {\\\"@index 2\\\": 2, \\\"parity\\\": \\\"even\\\"}\\n\\nbitwise_one_zero([3, 3, 3, 3, 3, 3]) ➞ {\\\"@index 0\\\": 3, \\\"parity\\\": \\\"odd\\\"}\\n```\\n\\n### Notes\\n- The use of `index()` and `min()` are restricted.\\n- You can read more about recursion (see **Resources** tab) if you aren't familiar with it  or haven't fully understood the concept before taking up this challenge.\",\"isHidden\":false,\"lab\":\"from inspect import getsource as src\\nfrom re import findall, search, M\\n\\ndef no_recur(fn):\\n  try:\\n    s, n = src(fn), fn.__name__\\n    if n == '<lambda>': n = 'bitwise_one_zero'\\n    return len(findall(n, s, M)) > 1\\n  except OSError: return True\\n\\ndef no_min_index(fn):\\n  try: return not search(r'min|.+\\\\.index(.+)', src(fn), M)\\n  except OSError: return True\\n\\nTest.assert_not_equals(no_recur(bitwise_one_zero), False, 'Recursion is required!')\\nTest.assert_not_equals(no_min_index(bitwise_one_zero), False,\\n    'The use of built-in functions index() and min() are prohibited!')\\n\\nnum_vector = [\\n  [107, 19, -18, -79, 36, 23, 97],\\n  [31, 7, 2, 13, 7, 9, 10, 13],\\n  [3, 3, 3, 3, 3, 3],\\n  [-31, -7, -13, -7, -9, -13],\\n  [1, 3, 9, 5, -1, 7, 9, 49],\\n  [63, 77, 13, 75, 91, 113],\\n  [6, 6, 6, 6, 6, 6]]\\nres_vector = [\\n  {\\\"@index 3\\\": -79, \\\"parity\\\": \\\"odd\\\"},\\n  {\\\"@index 2\\\": 2, \\\"parity\\\": \\\"even\\\"},\\n  {\\\"@index 0\\\": 3, \\\"parity\\\": \\\"odd\\\"},\\n  {\\\"@index 0\\\": -31, \\\"parity\\\": \\\"odd\\\"},\\n  {\\\"@index 4\\\": -1, \\\"parity\\\": \\\"odd\\\"},\\n  {\\\"@index 2\\\": 13, \\\"parity\\\": \\\"odd\\\"},\\n  {\\\"@index 0\\\": 6, \\\"parity\\\": \\\"even\\\"}]\\nfor i, x in enumerate(num_vector): Test.assert_equals(bitwise_one_zero(x), res_vector[i])\",\"language\":\"python3\",\"summary\":\"Write a function that returns the smallest integer in a list with its corresponding index and its parity. Although these tasks can be equivocally achievable with the use of some built-in and list functions, the purpose and intent of this challenge is for you to solve it recursively.\\n\\nOutput Structure:\\n{\\\"@index \\\" + indexofsmallest: smallest_integer, \\\"parity\\\": \\\"\",\"tags\":[\"recursion\",\"arrays\"],\"timestamp\":{\"$date\":1595756810267},\"title\":\"Recursion: Parity of the Smallest Integer\",\"stats\":{\"completed\":{\"total\":21,\"ratings\":[4,4,4,4,4,5,3,5,5,4,5,5,4,5,4,5,3,1,1,5,3,0,1,2],\"rators\":[\"a777e8chPvJkY3tKa\",\"aEm3Wvj2rFYRL8Lrb\",\"8PwfYqoDQFThzNtvf\",\"vTfyrr4pGddp8rbXc\",\"gJYuGdkXEWWmGRLzu\",\"xn7uGNKeAwPEkP9oA\",\"5dHucvf2qBYyKim7X\",\"DPi9QGLctq2y76KuE\",\"iS5BrkGLzJyPK7nKt\",\"eHcgvkTGsH7ZziqBo\",\"iojEnnY9FsMfYzp6f\",\"QRv96jmNaYsWkxQEG\",\"8sNv5PTHa7XQ8bNqR\",\"yjtdwc2AC4jA2RWtn\",\"tAF9Gf6PiGogbZuWs\",\"FQniC4DLnHxtBzDZ6\",\"T6iBEE2jp7f7iEF2P\",\"sKQjmCdScGruhBLgR\",\"s5M5RvgqR9BhB9JoC\"],\"quality\":[]},\"instructions\":{\"upvoters\":[],\"downvoters\":[]},\"flags\":0},\"editorId\":\"BkPgkDQGHm66X4Qai\",\"quality\":0,\"family\":[{\"_id\":\"q3LpnKujfvSZpu9qQ\",\"language\":\"javascript\"},{\"_id\":\"GTnW4bQAZQ38oHuyi\",\"language\":\"python3\"}]}}"]