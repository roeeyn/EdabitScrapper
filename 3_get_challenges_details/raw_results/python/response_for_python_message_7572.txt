a["{\"msg\":\"result\",\"id\":\"2491\",\"result\":{\"_id\":\"k9GSNAEL5mS4yPtLv\",\"author\":\"MyName\",\"authorId\":\"P7NmFbCJ5offXMRvB\",\"code\":\"def hamming_coder(block):\\n\\t\",\"difficulty\":4.888888888888889,\"quality\":0,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"Ednx95LBCaEGw79ab\",\"instructions\":\"This challenge is a continuation of [Error Detection Part 1: The Hamming Checker\\n](https://edabit.com/challenge/5k25ZqnuFgtgHNAqh). To recap:\\n- Every redundant bit in a **Hamming block** informs about the parity of the numbers of `1`s inside its region: a `0` indicates an even number of `1`s, and a `1` indicates an odd number of `1`s.\\n- Redundant bits are always placed in powers of two: index `1`, `2`, `4`, etc., or binary `1`, `10`, `100`, etc.\\n- All indices inside a region are related to the index of the redundant bit for that region: for the redundant bit in position `0100` (decimal `4`), the indices in its region are `0101`, `0110`, `0111`, `1100`, `1101`, `1110` and `1111`. Specifically, all these have a `1` for the third-to-last digit. This pattern applies to all regions:\\n![Indeces in binary](https://edabit-challenges.s3.amazonaws.com/0UAEbTJ.png)\\n- A block with _m_ bits needs _n_ redundant bits, where _2^n = m_.\\n\\nFor this challenge, your task is to write a function that takes a Hamming block and fills in all the redundant bits with the appropriate value. The redundant bits are already in place, but they are all `0`s.\\n\\nThis time, the bit indexed `0` will be put to use. This bit will encode information about the whole block, taking on the value (`0` or `1`) that makes the total number of `1`s even. Using this extra bit allows the receiver to detect if there have been two errors, albeit not their positions.\\n\\nYour code should work for blocks of different sizes (sizes will always be powers of two).\\n\\n### Examples\\n```\\nhamming_coder(\\\"0000010100011000\\\") ➞ \\\"0100110100011000\\\"\\n\\nhamming_coder(\\\"0000000001010000\\\") ➞ \\\"1010000001010000\\\"\\n\\nhamming_coder(\\\"00010111010110000111001110001010\\\") ➞ \\\"00110111010110000111001110001010\\\"\\n\\nhamming_coder(\\\"00000110001001000111010100100101\\\") ➞ \\\"10101110101001000111010100100101\\\"\\n```\\n\\n### Notes\\n- Redundant bits always have powers of two as their indices.\\n- Each region divides the block into two. Some regions divide the block vertically, with columns doubling in width; some others divide the block horizontally, with rows doubling in height. The redundant bits always sit at the top left corner of each region.  [Here's](https://i.imgur.com/vhaBWIk.png) an example of how a block size 32 would be partitioned.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"tests = [(0, '0000001001000101'), (1, '0001011001110111'), (2, '0001010100110010'), \\n(3, '00010001001010010001011101000001'), \\n(4, '00000001010010000110001001100000'), \\n(5, '00010011001011110010010111100101'), \\n(6, '0000010000100011011101001101010001000010100101110010000001101101'), \\n(7, '0000010000010010000111011001100001110000011100010100011110011001'), \\n(8, '00010011001001110010100001010111010101111111111110001101000110010001001101001010101101100100111110110010111110010101110000010011'), \\n(9, '00000010011111000000010001010000011010011001001010010011101011000010000010111010100100011000101000011110100110000001110000110001'), \\n(10, '0000011000110110011101000110001000010011110001000000111111000110010100000100111100110000101111110101001110001101110000010010100101011110000110000110100111101010110101100101000001111100111011011000110101100110010011010000111000101100011001000101000110111011')]\\n\\nsol = [(0, '1100101011000101'), (1, '0001111001110111'), (2, '1011110110110010'), \\n(3, '10011001101010010001011101000001'), \\n(4, '00001001010010001110001001100000'), \\n(5, '11010011001011110010010111100101'), \\n(6, '1110010010100011011101001101010011000010100101110010000001101101'), \\n(7, '0000010010010010100111011001100011110000011100010100011110011001'), \\n(8, '11110011101001111010100001010111110101111111111110001101000110011001001101001010101101100100111110110010111110010101110000010011'), \\n(9, '00001010011111001000010001010000011010011001001010010011101011001010000010111010100100011000101000011110100110000001110000110001'), \\n(10, '1010011000110110011101000110001010010011110001000000111111000110010100000100111100110000101111110101001110001101110000010010100101011110000110000110100111101010110101100101000001111100111011011000110101100110010011010000111000101100011001000101000110111011')]\\n\\nfor ind,i in enumerate(tests):\\n\\tprint('Test number '+ str(ind))\\n\\tTest.assert_equals(hamming_coder(i[1]), sol[ind][1])\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,4,5,5,5],\"quality\":[],\"rators\":[\"aEm3Wvj2rFYRL8Lrb\",\"8PwfYqoDQFThzNtvf\",\"QBgP4BySQAeCoCFf6\",\"gJYuGdkXEWWmGRLzu\"],\"total\":5},\"flags\":0},\"summary\":\"This challenge is a continuation of [Error Detection Part 1: The Hamming Checker\\n](https://edabit.com/challenge/5k25ZqnuFgtgHNAqh). To recap:\\nEvery redundant bit in a Hamming block informs about the parity of the numbers of 1s inside its region: a 0 indicates an even number of 1s, and a 1 indicates an odd number of 1s.\\nRedundant bits are always placed in power\",\"tags\":[\"logic\",\"bit_operations\"],\"timestamp\":{\"$date\":1600011929344},\"title\":\"Error Detection Part 2: The Hamming Coder\",\"family\":[{\"_id\":\"k9GSNAEL5mS4yPtLv\",\"language\":\"python3\"}]}}"]