a["{\"msg\":\"result\",\"id\":\"1515\",\"result\":{\"_id\":\"vQpLcEAWG6hHu6E5Z\",\"author\":\"Jason Rutz\",\"authorId\":\"sN9bLNiNtg8o7rzCP\",\"code\":\"def fib(n):\\n\\t\",\"difficulty\":2.111111111111111,\"quality\":4.45,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"6D5N3q55R8uXc82zG\",\"instructions\":\"The Fibonacci sequence is a classic use case for recursive functions since the value of the sequence at a given index is dependent on the last two values. More precisely, it's dependent on the *sum* of the previous two values.\\n\\nWrite a function named `fib` that takes an integer `n` as its input. It should return the Fibonacci sequence's value at index `n`.\\n\\n### Examples\\n```\\nfib(6) ➞ 8\\n# 0 + 1 = 1, 1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\\n\\nfib(1) ➞ 1\\n\\nfib(2) ➞ 1\\n```\\n\\n### Notes\\n- You should throw a `ValueError` if `n` is less than `0`.\\n- Assume the Fibonacci sequence's first two values (at indices `0` and `1`) are `0` and `1`.\\n- You *must* make `fib` a recursive function.\\n\\n### Tips\\n- You can call a function within itself to get the value a different iteration returns. This is called a \\\"recursive function\\\".\\n- If you're getting stuck, try looking up the math behind the Fibonacci sequence to see if that inspires you.\\n- Check the **Resources** tab for relevant information!\",\"isFree\":false,\"isHidden\":false,\"lab\":\"from sys import getrecursionlimit, setrecursionlimit\\nprev_limit = getrecursionlimit()\\n\\ndef is_correct_error(function, *args):\\n\\terror_type, message = args[-2:]\\n\\ttry:\\n\\t\\tfunction(*args[:-2])\\n\\t\\tTest.assert_equals(1, 0, 'Your function did not throw an error when it should have!')\\n\\texcept BaseException as e:\\n\\t\\tif message is not None:\\n\\t\\t\\tTest.assert_equals(type(e), type(error_type), message)\\n\\t\\t\\tif error_type.args:\\n\\t\\t\\t\\tTest.assert_equals(e.args, error_type.args, message)\\n\\t\\telse:\\n\\t\\t\\tTest.assert_equals(type(e), type(error_type))\\n\\t\\t\\tif error_type.args:\\n\\t\\t\\t\\tTest.assert_equals(e.args, error_type.args)\\n\\nTest.assert_equals(fib(1), 1)\\nTest.assert_equals(fib(2), 1)\\nTest.assert_equals(fib(0), 0, 'fib should be able to take 0 as an index!')\\n\\nis_correct_error(fib, -1, ValueError(), 'fib should throw a ValueError if n is less than 0!')\\nsetrecursionlimit(10)\\nis_correct_error(fib, 11, RuntimeError('maximum recursion depth exceeded in comparison'), 'fib should be a recursive function!')\\nsetrecursionlimit(prev_limit)\\n\\nTest.assert_equals(fib(3), 2)\\nTest.assert_equals(fib(4), 3)\\nTest.assert_equals(fib(5), 5)\\nTest.assert_equals(fib(6), 8)\\nTest.assert_equals(fib(7), 13)\\nTest.assert_equals(fib(8), 21)\\nTest.assert_equals(fib(9), 34)\\nTest.assert_equals(fib(10), 55)\\nTest.assert_equals(fib(11), 89)\\nTest.assert_equals(fib(12), 144)\\nTest.assert_equals(fib(13), 233)\\nTest.assert_equals(fib(14), 377)\\nTest.assert_equals(fib(15), 610)\\nTest.assert_equals(fib(16), 987)\\nTest.assert_equals(fib(17), 1597)\\nTest.assert_equals(fib(18), 2584)\\nTest.assert_equals(fib(19), 4181)\\nTest.assert_equals(fib(20), 6765)\\nTest.assert_equals(fib(21), 10946)\\nTest.assert_equals(fib(22), 17711)\\nTest.assert_equals(fib(23), 28657)\\nTest.assert_equals(fib(24), 46368)\\nTest.assert_equals(fib(25), 75025)\\nTest.assert_equals(fib(26), 121393)\\nTest.assert_equals(fib(27), 196418)\\nTest.assert_equals(fib(28), 317811)\\nTest.assert_equals(fib(29), 514229)\\nTest.assert_equals(fib(30), 832040)\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[2,2,2,2,2,2,2,1,2,3,2,2,0,2,4,3,1,2,2,3,2,4,3,4,2,2,2,2,3,3,2,3,3,0,2,0,0,0,3,3,2,2,3,2,5,0,1,0,1,2,3,3,2,4],\"quality\":[5,5,4,4,5,3,5,4,4,5,5,4,4,5,4,5,5,5,4,4],\"rators\":[\"sN9bLNiNtg8o7rzCP\",\"QRv96jmNaYsWkxQEG\",\"tpxMgkGSHwBjS95Ta\",\"SPYSWseH56TkTzKGf\",\"8PwfYqoDQFThzNtvf\",\"gJYuGdkXEWWmGRLzu\",\"aEm3Wvj2rFYRL8Lrb\",\"yjtdwc2AC4jA2RWtn\",\"gb9rvGus2Jv7bjZSs\",\"uN5t57RETi5y2z5W8\",\"6428wKHtwKkFdvBs5\",\"cR3ibTMxLyEdDFCHY\",\"HF28xZKSLM9wEuqNg\",\"CQhaiZqQcP87YteSG\",\"J5T8gZqiZXFuFDTQ7\",\"oBcs8GLX2ZFLXQy8y\",\"xn7uGNKeAwPEkP9oA\",\"yod5YhKtPqw2GfG9B\",\"CEd9tLdXeDeNHSzys\",\"tAF9Gf6PiGogbZuWs\",\"6MjSiiBLPcvXbXcaZ\",\"xhCe8aAuimqGyiWQe\",\"4fhjJBvLBWh6QeSih\",\"incG8tH2dwThHg35f\",\"PcB74cM6JmB5rt5uQ\",\"zFHTwKWb3BqRSTJfq\",\"qD2LrwaDrSdiybLKY\",\"ADi6nTBqP9ttcsEPq\",\"s5M5RvgqR9BhB9JoC\",\"Yp7uvStL97cC9fKkY\",\"Rdz7kzCHMT4WwRRyN\",\"ANbSYXiYsp4addoDq\",\"5Y3jeWnhLKBvuCdm7\",\"Jqk2uJZZxEv5wZFze\",\"8JyqsSbN2FJXPr3cw\",\"t5sZF4aR7a28Bm56W\",\"gXTAie79kiw28tx5u\",\"2QziknsznNeMPRh3g\",\"DPi9QGLctq2y76KuE\",\"9pzFiFK3ANLjQfnr2\",\"R29kgJ9M7R4qqwjcE\",\"iojEnnY9FsMfYzp6f\",\"cAP3n5NY64uoMwzRR\",\"oegsMgYbTKZZzPgWS\",\"srJ34BaybkQh3qRkM\",\"d8qtzoLB264iP8tdY\",\"AasGs8AeX9Lcb9xJn\",\"XHShZ3WMPgGEA2vkR\",\"HqmxnQJM66Y57twhn\",\"yhPBcN6xM7xdZJH9x\",\"GGdmhAvxXhqhhibJN\",\"gKnWjDjwrJh7MK2df\",\"T6iBEE2jp7f7iEF2P\",\"2PufnQcsHsfymufX3\",\"AFfw7cGg83uYk2Miy\",\"rhS8qXRjZcpDXkwnE\",\"5jC6kt3SXoABZBwsY\",\"Hteg6BcLmhSrwaeZr\",\"EeH2HPk4BtFif6sow\",\"rfyEkETeoS96QNH4e\",\"GTKsdeEihE636Le9i\",\"8sNv5PTHa7XQ8bNqR\",\"2qtde7moqrzm7B4Ht\",\"5HCu9Ydd86QgHDRNP\",\"BrTDhPJcACL2bsrpJ\",\"Ds7L5bksw2QRHjrKL\",\"J3upzLHuEwXH7Z2hx\",\"Dh7eZuDtu7EMWiDj6\",\"n2RkNBJQnPMswEnYT\"],\"total\":73},\"flags\":1},\"summary\":\"The Fibonacci sequence is a classic use case for recursive functions since the value of the sequence at a given index is dependent on the last two values. More precisely, it's dependent on the sum of the previous two values.\\n\\nWrite a function named fib that takes an integer n as its input. It should return the Fibonacci sequence's value at index n.\\n\\nExamples\\nf\",\"tags\":[\"recursion\",\"math\"],\"timestamp\":{\"$date\":1600814418488},\"title\":\"Fibonacci Recursion\",\"family\":[{\"_id\":\"xB6ojyF6eiepSW4DR\",\"language\":\"cpp\"},{\"_id\":\"Cfe88oSTXyxihiPhu\",\"language\":\"javascript\"},{\"_id\":\"vQpLcEAWG6hHu6E5Z\",\"language\":\"python3\"},{\"_id\":\"4Q6TiQZmeuAX8BsoT\",\"language\":\"ruby\"}]}}"]