a["{\"msg\":\"result\",\"id\":\"1388\",\"result\":{\"_id\":\"haaS4SBv42N3btcg5\",\"author\":\"ChrisCrossCrash\",\"authorId\":\"3SKmXhcLPPkmQhjip\",\"code\":\"def get_sha256_hash(txt):\\n\\t\",\"difficulty\":2.0697674418604652,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"zgMFXK9DJhegssPcG\",\"instructions\":\"Hash algorithms are easy to do one way, but essentially impossible to do in reverse. For example, if you hash something simple, like `password123`, it will give you a long code, unique to that word or phrase. Ideally, there's no way to do this in reverse. You can't take the hash code and go back to the word or phrase you started with.\\n\\nMake a function that returns the SHA-256 secure hash for a given string. The hash should be formatted in a hexadecimal digit string.\\n\\n### Examples\\n```\\nget_sha256_hash(\\\"password123\\\") ➞ \\\"ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f\\\"\\n\\nget_sha256_hash(\\\"Fluffy@home\\\") ➞ \\\"dcc1ac3a7148a2d9f47b7dbe3d733040c335b2a3d8adc7984e0c483c5b2c1665\\\"\\n\\nget_sha256_hash(\\\"Hey dude!\\\") ➞ \\\"14f997f08b8ad032dcb274198684f995d34043f9da00acd904dc72836359ae0f\\\"\\n```\\n\\n### Notes\\nBonus if you can do it without importing any libraries ;)\",\"isHidden\":false,\"lab\":\"Test.assert_equals(get_sha256_hash(\\\"hi\\\"), \\\"8f434346648f6b96df89dda901c5176b10a6d83961dd3c1ac88b59b2dc327aa4\\\")\\nTest.assert_equals(get_sha256_hash(\\\"password123\\\"), \\\"ef92b778bafe771e89245b89ecbc08a44a4e166c06659911881f383d4473e94f\\\")\\nTest.assert_equals(get_sha256_hash(\\\"don't use easy passwords\\\"), \\\"9fdfef802f06e384101080935fd3c938c60f92f528d520528b5c0491471a2be1\\\")\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[2,2,2,2,2,2,3,3,3,2,3,3,4,3,1,2,3,2,3,5,3,1,2,0,0,3,4,1,3,3,0,3,1,4,2,2,3,2,3,0,2,0,3,3,2,3,0,3,3,2,1,0,4,1,3,2,3,0,2,3,3,1,4,1,3,3,0,2,0,1,2,1,2,0,3,2,2,2,1,2,3,0,0,0,3,5],\"rators\":[\"3SKmXhcLPPkmQhjip\",\"2rc86eoe88DLhFeJD\",\"HZfJaSkjv8cChtogY\",\"tAF9Gf6PiGogbZuWs\",\"yoYQqaY6GszuTkNSs\",\"gMJhLdyw3tH7L96X2\",\"Jqk2uJZZxEv5wZFze\",\"6ZXYTAfkYvbNK3JaR\",\"GamaMNrnhrjj5tXTx\",\"ydEdzuCCZt4yny9Rq\",\"w6YLFuizZ4QGqNeMX\",\"aCNWav8S8Try9RkC6\",\"DkYeAMDMzM8F6Zba5\",\"hAzy9apJgLWwRFGPJ\",\"eHcgvkTGsH7ZziqBo\",\"7BvK9WWXi9Arqh63Q\",\"Lw8oRc5SERsuntXMo\",\"zgoEhAyhrjnsSLPGw\",\"ab7BsQuhDo3QgE6bh\",\"T9PMj9TH6DpDiAMKr\",\"n5xGypteaCL2bRGWM\",\"ALcgrkPgXfJMvE5CX\",\"LtD5jQnA63GoHjAq2\",\"u5u2YpHXiNgzDNJdX\",\"C4QntmkYtB89GNtpd\",\"4zh9hoYRedNq6GxN7\",\"4CFzv558qbGcpQwc4\",\"MHHvSTA72Gga2LGFz\",\"AasGs8AeX9Lcb9xJn\",\"pkQBaSzukotPEXmrD\",\"YifQYJmabCfJ6ftia\",\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"kYWb8BwpKwunQkxeX\",\"pWD2YC5s4YRCxFc2i\",\"ZNnsMeNkdDhHjSrZb\",\"SKeSSfqSmCk65vjYh\",\"8DH2opL3T5kdcoiRJ\",\"YRstQuthRkFeBiXug\",\"gJYuGdkXEWWmGRLzu\",\"Nb6LYPoQP6KJZt8mz\",\"v9KtC8YLbMWmXiW2H\",\"n2BRY9X8899dcG8Bw\",\"Z4M3NAa4TXquMNkHe\",\"vwq4Zsm3TjqPKvavg\",\"bv6ibp8haYQmyXzWG\",\"SgZ2t9xFuRqdJGofp\",\"iojEnnY9FsMfYzp6f\",\"yjtdwc2AC4jA2RWtn\",\"DEDniTrstQYGounXT\",\"HF28xZKSLM9wEuqNg\",\"KsBCRyLskTm6rJHic\",\"nWbwmuxSsM4WdHLHx\",\"qD2LrwaDrSdiybLKY\",\"q6peoEWzrwZzogT5w\",\"iS5BrkGLzJyPK7nKt\",\"gojReckJvzYvoHqSu\",\"QRv96jmNaYsWkxQEG\",\"xn7uGNKeAwPEkP9oA\",\"p8qqFdJ3FSk5x9z3G\",\"wEmFRYs7YywLBuyzj\",\"YRAzEBJoLvSaiPtYx\",\"Yp7uvStL97cC9fKkY\",\"J3upzLHuEwXH7Z2hx\",\"LfDeQBAH37L7wgT4Z\",\"DPi9QGLctq2y76KuE\",\"yTtSCvGPyYna6JuRC\",\"gXTAie79kiw28tx5u\",\"XNmN6ztj36a7eChbD\",\"qAby4AWXmTNeusvg3\",\"oBcs8GLX2ZFLXQy8y\",\"cAP3n5NY64uoMwzRR\",\"w67KfQgZ6WAeY7K4Y\",\"9pzFiFK3ANLjQfnr2\",\"GGdmhAvxXhqhhibJN\",\"BrTDhPJcACL2bsrpJ\",\"H9KZi2cjt4FwH7qog\",\"LQxof8pGabGuWP7Gn\",\"rfyEkETeoS96QNH4e\",\"gKnWjDjwrJh7MK2df\",\"2PufnQcsHsfymufX3\",\"o4ixjQGSaYqA2JoM4\",\"yod5YhKtPqw2GfG9B\",\"CJxPyhJirydwiaj7x\",\"8sNv5PTHa7XQ8bNqR\",\"3Zmh5qrGG4PfsS4qo\",\"Ds7L5bksw2QRHjrKL\",\"T6iBEE2jp7f7iEF2P\",\"gzEkiFEshpEp8GMim\",\"CHvzhtXnv8HTbPQ56\",\"g6dBdzLo5fAiNGz6r\",\"J5T8gZqiZXFuFDTQ7\"],\"total\":99,\"quality\":[5,5,4,5,5,5,5,5,4,5,5]},\"flags\":0},\"summary\":\"Hash algorithms are easy to do one way, but essentially impossible to do in reverse. For example, if you hash something simple, like password123, it will give you a long code, unique to that word or phrase. Ideally, there's no way to do this in reverse. You can't take the hash code and go back to the word or phrase you started with.\\n\\nMake a function that retur\",\"tags\":[\"cryptography\",\"strings\",\"algorithms\"],\"timestamp\":{\"$date\":1576359223191},\"title\":\"Get SHA-256 Hash\",\"quality\":4.818181818181818,\"family\":[{\"_id\":\"9AqYtzGYcKwGM8hhQ\",\"language\":\"cpp\"},{\"_id\":\"pxfkEdxgXPKgy7FEb\",\"language\":\"java\"},{\"_id\":\"tPK2g4dGnrnqLZRX2\",\"language\":\"javascript\"},{\"_id\":\"haaS4SBv42N3btcg5\",\"language\":\"python3\"},{\"_id\":\"QDho8v7hXPmWhT4p6\",\"language\":\"ruby\"},{\"_id\":\"rzuHdWipprPyLZLmm\",\"language\":\"swift\"}]}}"]