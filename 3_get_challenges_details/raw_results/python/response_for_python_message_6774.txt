a["{\"msg\":\"result\",\"id\":\"2095\",\"result\":{\"_id\":\"mrrKngM2fqDEDMXtS\",\"author\":\"Helen Yu\",\"authorId\":\"mNMQvcxKSSvqqMYCH\",\"code\":\"def can_patch(bridge, planks):\\n\\t\",\"difficulty\":2.9305555555555554,\"familyId\":\"YZKqQ4XQWESApXKrS\",\"instructions\":\"A broken bridge can be represented by `1`s and `0`s, where contiguous `0`s represent holes. You can walk across a bridge with a hole with a maximum width of 1, but any holes bigger than that you must fix first. For example, the bridge below is walkeable:\\n\\n```\\n[1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1]\\n```\\n\\nThis bridge is not:\\n\\n```\\n[1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n```\\n\\nYou own several wooden planks, each with different widths. You can patch the holes on the bridge with these planks. More specifically, a plank size `n` can fill a `n`-sized hole. If you had a plank of size `2`, the un-walkeable bridge above could be filled in:\\n\\n```\\n[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n```\\n\\nBut even if you only had a plank of size `1`, you could still transform the unwalkeable bridge into a walkeable one:\\n\\n```\\n[1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n```\\n\\nWrite a function that takes in a broken bridge, a list of plank sizes, and returns `True` if the bridge can be patched up enough to walk over, and `False` otherwise.\\n\\n\\n\\n### Examples\\n```\\ncan_patch([1, 0, 0, 0, 0, 0, 0, 1], [5, 1, 2]) ➞ True\\n# You can use the 5 plank to transform the 6 hole to a 1 hole.\\n# Leftover planks [1, 2] are okay.\\n\\ncan_patch([1, 0, 0, 0, 0, 0, 0, 1], [4, 1, 2, 3, 4]) ➞ False\\n# None of your planks are long enough (you can't combine them).\\n\\ncan_patch([1, 0, 0, 1, 1, 0, 0, 0, 1], [1, 2]) ➞ True\\n\\ncan_patch([1, 0, 0, 1, 1, 0, 0, 0, 1], [1, 1]) ➞ False\\n```\\n\\n### Notes\\n- Individual planks may NOT be combined to form a longer plank.\\n- Leftover planks are okay.\",\"lab\":\"Test.assert_equals(can_patch([1, 0, 0, 1], [1]), True)\\nTest.assert_equals(can_patch([1, 0, 0, 1], [1, 2]), True)\\nTest.assert_equals(can_patch([1, 0, 0, 1], []), False)\\nTest.assert_equals(can_patch([1, 0, 1, 1], []), True)\\nTest.assert_equals(can_patch([1, 0, 1, 0, 1, 0, 1, 0, 1], []), True)\\nTest.assert_equals(can_patch([1, 0, 0, 0, 0, 0, 0, 1], [5, 1, 2]), True)\\nTest.assert_equals(can_patch([1, 0, 0, 0, 0, 0, 0, 1], [4, 1, 2, 3, 4]), False)\\nTest.assert_equals(can_patch([1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 1]), False)\\nTest.assert_equals(can_patch([1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 1, 1]), True)\\nTest.assert_equals(can_patch([1, 0, 0, 1, 1, 0, 0, 0, 1], [1, 2]), True)\\nTest.assert_equals(can_patch([1, 0, 0, 1, 1, 0, 0, 0, 1], [1, 1]), False)\\nTest.assert_equals(can_patch([1, 0, 0, 1, 1, 1, 0, 0, 1], [1, 1]), True)\\nTest.assert_equals(can_patch([1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 3, 1]), True)\\nTest.assert_equals(can_patch([1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 3, 1, 5, 5]), True)\\nTest.assert_equals(can_patch([1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 2, 2]), False)\",\"language\":\"python3\",\"summary\":\"A broken bridge can be represented by 1s and 0s, where contiguous 0s represent holes. You can walk across a bridge with a hole with a maximum width of 1, but any holes bigger than that you must fix first. For example, the bridge below is walkeable:\\n\\n[1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1]\\n\\nThis bridge is not:\\n\\n[1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1\",\"tags\":[\"arrays\",\"validation\",\"higher_order_functions\"],\"timestamp\":{\"$date\":1554060023299},\"title\":\"Broken Bridge\",\"stats\":{\"completed\":{\"total\":71,\"ratings\":[2,2,2,2,2,2,2,2,2,2,2,3,4,3,3,3,3,2,4,4,3,4,3,1,4,1,3,3,3,4,5,4,3,3,4,5,3,3,4,3,2,2,3,4,2,2,4,3,4,3,4,2,4,2,4,4,3,2,2,4,3,3,3,3,2,3,4,3,1,4,2,3],\"rators\":[\"mNMQvcxKSSvqqMYCH\",\"Q27wyMg5RWcDTJxs3\",\"8JyqsSbN2FJXPr3cw\",\"yZvzB3qFb8pkHy4dg\",\"tAF9Gf6PiGogbZuWs\",\"gb9rvGus2Jv7bjZSs\",\"T3ZAuoMrJjvZwN55B\",\"PFjMZGHNAPTkgd7tq\",\"AYaEkTWLMmfzpwejr\",\"cecRRLKKu5R62D5xE\",\"DJD9vvwqQmjfwdGpt\",\"4zKhf6cdq7YRywZRF\",\"MXjxGML2X75x64vJo\",\"6fwzAwFY549EuSvms\",\"yZzvg933wFk6uCLyc\",\"BFNm9gacwba9KyLFW\",\"td7qPZ7Lv4pEWT2Ya\",\"BgP7LFjSWhPvp547w\",\"TNMAJidLpPdH4kmBv\",\"7g3vZaQXhLpxrajyg\",\"3ifAHQzsMasfQySoL\",\"P59rek6gvwTzHvRYa\",\"GCxj7RJCeWYNxj8oQ\",\"hsrNYf3WbexXJKhCq\",\"pMuvoqcmxHbuRSfb9\",\"nF9pCCzbGDhzvWgaw\",\"D6Z9oT2ZhjBCxuL2o\",\"jYJ26SiLKBu5GRumq\",\"eYWgXzijKqfqgZNDi\",\"HqmxnQJM66Y57twhn\",\"s5M5RvgqR9BhB9JoC\",\"Jqk2uJZZxEv5wZFze\",\"7b5t29Hsd7iD9c5CT\",\"2innwjWqxJHo4eRGh\",\"8PwfYqoDQFThzNtvf\",\"Yp7uvStL97cC9fKkY\",\"aEm3Wvj2rFYRL8Lrb\",\"WLFPvm65aHfgwQy7N\",\"AasGs8AeX9Lcb9xJn\",\"Nua6T3dBurBy3Qfg9\",\"mDWNyaaQ9hvPCRzSd\",\"fznzd3qnvtbFkkizz\",\"ZNnsMeNkdDhHjSrZb\",\"n2BRY9X8899dcG8Bw\",\"Ecg4m7srYGgZsb4Ck\",\"xn7uGNKeAwPEkP9oA\",\"f2BoqyCpgnmjEjLqx\",\"gJYuGdkXEWWmGRLzu\",\"PXAcsKkssS2yLyDv2\",\"v9KtC8YLbMWmXiW2H\",\"spqXrjG3ZFa2j5uTR\",\"yTtSCvGPyYna6JuRC\",\"HF28xZKSLM9wEuqNg\",\"iS5BrkGLzJyPK7nKt\",\"8sNv5PTHa7XQ8bNqR\",\"qAby4AWXmTNeusvg3\",\"iojEnnY9FsMfYzp6f\",\"GTKsdeEihE636Le9i\",\"QRv96jmNaYsWkxQEG\",\"J3upzLHuEwXH7Z2hx\",\"qZQxPQ2kaNKAMesHT\",\"yjtdwc2AC4jA2RWtn\",\"PWgzeK859suojbrRx\",\"MpfytGFYF77emJ3cT\",\"buX4mCQhtXCfBjeno\",\"T6iBEE2jp7f7iEF2P\",\"2PufnQcsHsfymufX3\",\"gXTAie79kiw28tx5u\",\"rhS8qXRjZcpDXkwnE\"],\"quality\":[5,5,5,5,5,5]},\"tests\":{\"score\":0,\"rators\":[\"mNMQvcxKSSvqqMYCH\"]},\"instructions\":{\"score\":0,\"rators\":[\"mNMQvcxKSSvqqMYCH\"]},\"flags\":0},\"editorId\":\"BkPgkDQGHm66X4Qai\",\"isHidden\":false,\"quality\":5,\"family\":[{\"_id\":\"nvQDz5F4g2Prtpgx5\",\"language\":\"cpp\"},{\"_id\":\"tQNGydfWqZueRgmDC\",\"language\":\"javascript\"},{\"_id\":\"mrrKngM2fqDEDMXtS\",\"language\":\"python3\"},{\"_id\":\"knpGsaWydLBRBs4c3\",\"language\":\"ruby\"}]}}"]