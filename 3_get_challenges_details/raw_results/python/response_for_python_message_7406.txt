a["{\"msg\":\"result\",\"id\":\"2409\",\"result\":{\"_id\":\"wx8DuvZ98BAcPAT8i\",\"author\":\"joegal\",\"authorId\":\"fznzd3qnvtbFkkizz\",\"code\":\"def validate(start, end, num, answer):\\n    '''\\n    Validates solutions to move_discs. Checks that num matches answer[0], and\\n    the moves in answer[1] lead validly from config start to end.\\n\\t\\tDO NOT REMOVE OR EDIT\\n    '''\\n    L =('L', 2,0); M = ('M', 4,3); R = ('R', 7, 5)  # slots:name, top idx, low idx\\n    discs = ''.join(d for d in start if d != '0') # valid disc numbers\\n    \\n    try:\\n        assert len(answer) == 2 and isinstance(answer[0],int) and isinstance(answer[1],list),\\\\\\n        'Malformed answer: should be (int, list)'\\n        num1, moves = answer\\n        assert num1 == num, 'Min number of moves incorrect'\\n        assert len(moves) == num, 'Actual number of moves incorrect'\\n\\n        config = start\\n        for move in moves:\\n            assert len(move) == 4 and move[1:3] == '->' and move[3] in 'LMR',\\\\\\n                   'Invalid move string ' + move\\n            disc, slot = move[0], eval(move[3])\\n            assert disc in discs, 'Disc ' + disc + ' not in valid discs ' + discs\\n            idx = config.index(disc)\\n            \\n            # check moved the top disc in its slot\\n            source_slot = L if 0 <= idx <= 2 else M if 3 <= idx <= 4 else R\\n            assert all(config[i] == '0' for i in range(idx+1,source_slot[1] + 1)), \\\\\\n                   'Move ' + move + ' invalid: ' + 'can only move the top disc in a slot'\\n            assert '0' in config[slot[2]:slot[1]+1],\\\\\\n                   'Move ' + move + ' invalid: ' + 'destination slot is full'\\n            \\n            # apply move to update config\\n            j = config[slot[2]:slot[1]+1].index('0') + slot[2]\\n            config2 = list(config)\\n            config2[idx], config2[j] = config2[j], config2[idx] #swap\\n            config = ''.join(config2)\\n\\n        assert config == end, 'Final config ' + config + ' does not match end: ' + end\\n        return True\\n\\n    except AssertionError as err:\\n        print(err)\\n        return False\\n\\t\\t\\t\\t\\ndef move_discs(start, end):\\n\\t\",\"difficulty\":4.1,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"b3yrfrW3ykuvyRL3X\",\"instructions\":\"There are 3 adjacent slots - L, M and R - which can each hold a number of discs. L can hold 3 discs, M can hold 2 and L 3. The total number of discs can vary  from 3 to 5, and the discs are numbered 1, 2, 3 and up to 5. From a given  configuration of discs, it is possible to move 1 disc at a time provided the disc concerned is top of its slot and there is an available slot in the destination slot.\\n\\nWrite a function which takes 2 parameters (start and end) and returns a tuple (n, moves) where n is the minimum number of moves needed to move from start to end and moves is a list of the moves required to effect the changes. start and end are 8 digit strings where the 1st 3 are slot L, next 2 M and the last 3 R. Locations are shown from bottom to top within each slot, and empty locations are represented by 0s. So configuration '15040230' represents disc 5 above 1 in slot L, 4 in slot M and 3 above 2 in slot R. '45000231' encodes 5 above 4 in slot L, an empty slot M and 1 above 3 above 2 in slot R.\\n\\nA move is a string in the form `<disc>-><slot>`. So to move disc 5 to slot M you would write \\\"5->M\\\"; 4 to slot R would be \\\"4->R\\\" and 3 to L \\\"3->L\\\". Slots act like stacks; you can only take the top disc and slots fill up from the bottom up so you can never have a space below a disc.\\n\\n### Examples\\n```\\nmove_discs(\\\"15040230\\\", \\\"45000231\\\") -> (6,[\\\"4->R\\\",\\\"5->M\\\",\\\"1->M\\\",\\\"4->L\\\",\\\"1->R\\\",\\\"5->L\\\"])\\n# \\\"15040230\\\" with \\\"4->R\\\" gives \\\"15000234\\\"\\n# \\\"15000234\\\" with \\\"5->M\\\" gives \\\"10050234\\\"\\n# \\\"10050234\\\" with \\\"1->M\\\" gives \\\"00051234\\\"\\n# \\\"00051234\\\" with \\\"4->L\\\" gives \\\"40051230\\\"\\n# \\\"40051230\\\" with \\\"1->R\\\" gives \\\"40050231\\\"\\n# \\\"40050231\\\" with \\\"5->L\\\" gives \\\"45000231\\\"\\n```\\n\\n### Notes\\n- Start and end will always be valid configurations - you can deduce the number of discs to move from either.\\n- There may be more than 1 minimum sequence of moves. To check this, the Code section contains the validate function. This checks that the minimum number of moves have been made and that each is legal and applying them in sequence leads from start of end. You may find it useful for debugging your code as you develop it.\\n- If you are unsure how to proceed, the Resources section may provide some pointers.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"def validate(start, end, num, answer):\\n    '''\\n    Validates solutions to move_discs. Checks that num matches answer[0], and\\n    the moves in answer[1] lead validly from config start to end.\\n\\t\\t'''\\n    L =('L', 2,0); M = ('M', 4,3); R = ('R', 7, 5)  # slots:name, top idx, low idx\\n    discs = ''.join(d for d in start if d != '0') # valid disc numbers\\n    \\n    try:\\n        assert len(answer) == 2 and isinstance(answer[0],int) and isinstance(answer[1],list),\\\\\\n        'Malformed answer: should be (int, list)'\\n        num1, moves = answer\\n        assert num1 == num, 'Min number of moves incorrect'\\n        assert len(moves) == num, 'Actual number of moves incorrect'\\n\\n        config = start\\n        for move in moves:\\n            assert len(move) == 4 and move[1:3] == '->' and move[3] in 'LMR',\\\\\\n                   'Invalid move string ' + move\\n            disc, slot = move[0], eval(move[3])\\n            assert disc in discs, 'Disc ' + disc + ' not in valid discs ' + discs\\n            idx = config.index(disc)\\n            \\n            # check moved the top disc in its slot\\n            source_slot = L if 0 <= idx <= 2 else M if 3 <= idx <= 4 else R\\n            assert all(config[i] == '0' for i in range(idx+1,source_slot[1] + 1)), \\\\\\n                   'Move ' + move + ' invalid: ' + 'can only move the top disc in a slot'\\n            assert '0' in config[slot[2]:slot[1]+1],\\\\\\n                   'Move ' + move + ' invalid: ' + 'destination slot is full'\\n            \\n            # apply move to update config\\n            j = config[slot[2]:slot[1]+1].index('0') + slot[2]\\n            config2 = list(config)\\n            config2[idx], config2[j] = config2[j], config2[idx] #swap\\n            config = ''.join(config2)\\n\\n        assert config == end, 'Final config ' + config + ' does not match end: ' + end\\n        return True\\n\\n    except AssertionError as err:\\n        print(err)\\n        return False\\n\\ntests = [\\n('54213000','31000245',5), ('40051230','30050214',5), ('43010200','41032000',4),\\n('10020300','30020100',3), ('12300000','00000123',5), ('13042000','40020310',5),\\n('21300540','25031400',7), ('40010230','30000214',5), ('00052314','41025300',6),\\n('12000300','21000300',4)\\n]\\n\\nfor s, e, n in tests:\\n    Test.assert_equals(validate(s,e,n,move_discs(s,e)), True)\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[4,4,4,4,4,4,4,5,3,5],\"rators\":[\"fznzd3qnvtbFkkizz\",\"aEm3Wvj2rFYRL8Lrb\",\"8PwfYqoDQFThzNtvf\",\"yjtdwc2AC4jA2RWtn\",\"iS5BrkGLzJyPK7nKt\"],\"total\":6,\"quality\":[]},\"flags\":0},\"summary\":\"There are 3 adjacent slots - L, M and R - which can each hold a number of discs. L can hold 3 discs, M can hold 2 and L 3. The total number of discs can vary  from 3 to 5, and the discs are numbered 1, 2, 3 and up to 5. From a given  configuration of discs, it is possible to move 1 disc at a time provided the disc concerned is top of its slot and there is an a\",\"tags\":[\"algorithms\",\"data_structures\",\"games\"],\"timestamp\":{\"$date\":1594480912992},\"title\":\"Move the Discs\",\"quality\":0,\"family\":[{\"_id\":\"wx8DuvZ98BAcPAT8i\",\"language\":\"python3\"}]}}"]