a["{\"msg\":\"result\",\"id\":\"2430\",\"result\":{\"_id\":\"Zzmb2LRbjzq3b2kYw\",\"author\":\"joegal\",\"authorId\":\"fznzd3qnvtbFkkizz\",\"code\":\"class Trie:\\n\\t\\ndef load(words):\\n\\t\",\"difficulty\":4.333333333333333,\"editorId\":\"fznzd3qnvtbFkkizz\",\"familyId\":\"TAoKJjFc7hKtMkiN2\",\"instructions\":\"A **trie** is a specialized type of tree data structure. When used in the context of a dictionary, each node stores the entire alphabet, and words can be reTRIEved by traversing down a branch part of the tree. The structure of a trie tree is a set of linked tries emanating from a head trie. Each trie contains a set of pointers (child tries), one for each alphabetic value.\\n\\nThe image below gives a representation of how a trie dictionary might store the words peter, piper, picked, peck, pickled, and peppers. For simplicity, most of the child nodes are omitted but the tree hierarchy can be readily seen and how a letter at a given level branches out (e.g p, pe, etc).\\n\\n![Trie Hierarchy](https://edabit-challenges.s3.amazonaws.com/sZOrNXzlQICVv5ePpav1-g.jpg)\\n\\nWhat is not clear is how the end of a word is recognized. There are many ways to do this, but for a simple dictionary, it is sufficient to have a flag indicating if the trie represents the end of a word or not. Hence a\\nword proceeds letter by letter from the head trie. As the words are unique, the full path for any individual word is also unique, although paths are shared where common (think how \\\"help\\\" and \\\"helpless\\\" would be represented).\\n\\nFor this challenge, we are going to construct a `Trie` class which can hold a set of lower case English letter words, together with methods and a function to allow it to be used in a basic way:\\n\\n- Function `load(words)` \u2060— `words` is a list of words that will be the initial set for the dictionary. The function should create the trie, load the words then return a pointer to the head trie.\\n- Instance method `update(self, words)` \u2060— This adds any words in the list words which are not already contained in the dictionary.\\n- Instance method `is_word(self, word)` \u2060— Returns `True` if `word` is in the dictionary, otherwise `False`.\\n- Instance method `remove(self, word`) \u2060— Removes `word` from the dictionary if it's present, otherwise no action.\\n - Instance method `contents(self, start=\\\"a\\\", end=\\\"z\\\")` \u2060— Returns a list of all or some of the words in the dictionary in ascending alphabetical order. If the start and/or end is present, only return the words which start with the letters between the start and end inclusive. `start` and `end` should be validated to ensure `end` is not before `start`; if it is, return the string `\\\"End cannot be earlier in the alphabet than start\\\"`.\\n If the dictionary is empty, return the string `\\\"Dictionary is currently empty\\\"`.\\n- Class/static `method num_words()` \u2060— Should return the number of words currently in the dictionary. If the dictionary is empty, return the string `\\\"Dictionary is currently empty\\\"`.\\n\\n### Examples\\n```\\nd = load([\\\"Peter\\\", \\\"Piper\\\", \\\"picked\\\", \\\"peppers\\\"])\\nd.contents() ➞ [\\\"peppers\\\", \\\"peter\\\", \\\"picked\\\", \\\"piper\\\"]\\nd.num_words() ➞ 4\\nd.remove(\\\"peppers\\\")\\nd.is_word(\\\"peppers\\\") ➞ False\\nTrie.num_words() ➞ 3\\nd.update([\\\"pineapples\\\"])\\nd.contents(\\\"p\\\",\\\"p\\\") ➞ [\\\"peter\\\", \\\"picked\\\", \\\"pineapples\\\", \\\"piper\\\"]\\n```\\n\\n### Notes\\n- Although words are stored in lower case in the dictionary, words input to load, update and `is_word` may contain capitals. The word lists input to load and update may also contain duplicates.\\n- Take extra care with the `remove` method \u2060— if you are removing \\\"hope\\\", for example, you need to be sure you can still access \\\"hopeful\\\" if that's present.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"wordsets = [\\n            ['antidisestablishmentarianism',\\n             'apple','banana','orange','hello','favourite','colour','hopeful','bee','a'],\\n            ['Happy','sad','miserable','coronavirus','corona','color','colorful',\\n             'distressed','evangelical','Filibuster','sad','zygote','horribleness']\\n           ]\\nfor words in wordsets:\\n    d = load(words)\\n    Test.assert_equals(isinstance(d,Trie), True,'Not a Trie')\\n    words = [word.lower() for word in words]\\n    Test.assert_equals(d.contents(), sorted(set(words)),'Contents do not match')\\n    Test.assert_equals(d.num_words(), len(set(words)), 'Number of words do not match')\\n    d.update(['horrible','hopelessness'])\\n    d.update(['hopelessness'])\\n    Test.assert_equals(d.contents(), sorted(set(words+['horrible','hopelessness'])),'Contents do not match')\\n    Test.assert_equals(d.num_words(),len(set(words))+2, 'Number of words do not match')\\n    Test.assert_equals(d.is_word('horrible'), True, 'should be in dictionary')\\n    d.remove('horrible')\\n    Test.assert_equals(d.contents(), sorted(set(words+['hopelessness'])),'Contents do not match')\\n    Test.assert_equals(d.num_words(),len(set(words))+1, 'Number of words do not match')\\n    Test.assert_equals(d.is_word('horrible'), False, 'should not be in dictionary')\\n    d.remove('horrendous')  # never in dictionary - should have no effect\\n    Test.assert_equals(d.is_word('horrendous'), False, 'should not be in dictionary')\\n    Test.assert_equals(d.contents(), sorted(set(words+['hopelessness'])),'Contents do not match')\\n    Test.assert_equals(d.num_words(),len(set(words))+1, 'Number of words do not match')\\n\\nd = Trie()\\nTest.assert_equals(d.contents(),'Dictionary is currently empty','Should be empty')\\nd = load(wordsets[1])\\nexpected = ['color', 'colorful', 'corona', 'coronavirus', 'distressed']\\nTest.assert_equals(d.contents('c','d'),expected,'Contents not matching for this range')\\nTest.assert_equals(d.contents('x','m'),'End cannot be earlier in the alphabet than start','Start is before end')\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[4,4,4,4,4,4,5,5,5,3,5,4,4,5,5],\"rators\":[\"fznzd3qnvtbFkkizz\",\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"xn7uGNKeAwPEkP9oA\",\"Wv2vJnEj8ywNmARoF\",\"h4x2jaMdj5aQZbW5g\",\"eHcgvkTGsH7ZziqBo\",\"yjtdwc2AC4jA2RWtn\",\"JKb5rhL6DKcCAypF9\",\"gJYuGdkXEWWmGRLzu\"],\"total\":12,\"quality\":[]},\"flags\":0},\"summary\":\"A trie is a specialized type of tree data structure. When used in the context of a dictionary, each node stores the entire alphabet, and words can be reTRIEved by traversing down a branch part of the tree. The structure of a trie tree is a set of linked tries emanating from a head trie. Each trie contains a set of pointers (child tries), one for each alphabeti\",\"tags\":[\"classes\",\"data_structures\",\"recursion\"],\"timestamp\":{\"$date\":1597423685123},\"title\":\"Fancy a Dictionary? Give it a Trie!\",\"quality\":0,\"family\":[{\"_id\":\"Zzmb2LRbjzq3b2kYw\",\"language\":\"python3\"}]}}"]