a["{\"msg\":\"result\",\"id\":\"2191\",\"result\":{\"_id\":\"2nciiXZN4HCuNEmAi\",\"author\":\"Deep Xavier\",\"authorId\":\"a777e8chPvJkY3tKa\",\"code\":\"def flatten(r):\\n\\t# Your recursive solution here.\\n\\treturn flatten(r)\",\"difficulty\":3.3684210526315788,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"eu9ejyrePk6moD6xX\",\"instructions\":\"The nesting of lists can be viewed indirectly as curves and barriers of the real data embedded in lists, thus, defeats the very purpose of directly accessing them thru indexes and slices. In this challenge, a function is required to **flatten those curves** (i.e. level, iron, compress, raze, topple) and expose those data as a **single list** and not as a *list of lists*.\\n\\n### Examples\\n```\\nflatten([[[[[[\\\"direction\\\"], [372], [\\\"one\\\"], [[[[[[\\\"Era\\\"]]]], \\\"Sruth\\\", 3337]]], \\\"First\\\"]]]])\\n➞ [\\\"direction\\\", 372, \\\"one\\\", \\\"Era\\\", \\\"Sruth\\\", 3337, \\\"First\\\"]\\n\\nflatten([[4666], [5394], [466], [[[\\\"Saskia\\\", [[[[[\\\"DXTD\\\"]], \\\"Lexi\\\"]]]]]]])\\n➞ [4666, 5394, 466, \\\"Saskia\\\", \\\"DXTD\\\", \\\"Lexi\\\"]\\n\\nflatten([[696], [\\\"friend\\\"], [\\\"power\\\"], [[[[\\\"Marcus\\\"]]]], [\\\"philus\\\"]])\\n➞ [696, \\\"friend\\\", \\\"power\\\", \\\"Marcus\\\", \\\"philus\\\"]\\n\\nflatten([[[\\\"deep\\\"], [[[\\\"ocean\\\"]]], [[\\\"Marge\\\"]], [\\\"rase\\\", 876]]])\\n➞ [\\\"deep\\\", \\\"ocean\\\", \\\"Marge\\\", \\\"rase\\\", 876]\\n```\\n\\n### Notes\\n- There are no empty lists to handle.\\n- You're expected to solve this challenge using a **recursive approach**.\\n- You can read on more topics about recursion (see **Resources** tab) if you aren't familiar with it yet or haven't fully understood the concept behind it before taking up this challenge.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"from inspect import getsource\\nfrom re import findall, MULTILINE\\n\\ndef check_recursive(fn):\\n  try:\\n    src, n = getsource(fn), fn.__name__\\n    if n == '<lambda>': n = src.split('=')[0].strip()\\n    return len(findall(n, src, flags=MULTILINE)) > 1\\n  except OSError: return True\\n\\nfor v in [True, False]:\\n  if v: Test.assert_equals(check_recursive(flatten), v)\\n  else: Test.assert_not_equals(check_recursive(flatten), v, 'Recursion is required!')\\n\\narr_vectors = [\\n  [[[[[['direction'], [372], ['one'], [[[[[['Era']]]], 'Sruth', 3337]]], 'First']]]],\\n  [[4666], [5394], [466], [[['Saskia', [[[[['DXTD']], 'Lexi']]]]]]],\\n  [[696], ['friend'], ['power'], [[[['Marcus']]]], ['philus']],\\n  [[['deep'], [[['ocean']]], [['Marge']], ['rase', 876]]],\\n  ['I', [19.79, 'love', [12.17], \\\"edabit\\\"]], \\n  [['The', ['first', ['of', [\\\"May\\\", 0.0, 1, ]]], 2, 3, 4]],\\n  [7, [11, 'lived', [[229]]]], \\n  ['and', 6, [3, 'scores', ['six', 100]]]]\\nres_vectors = [\\n  ['direction', 372, 'one', 'Era', 'Sruth', 3337, 'First'],\\n  [4666, 5394, 466, 'Saskia', 'DXTD', 'Lexi'],\\n  [696, 'friend', 'power', 'Marcus', 'philus'],\\n  ['deep', 'ocean', 'Marge', 'rase', 876],\\n  ['I', 19.79, 'love', 12.17, 'edabit'],\\n  ['The', 'first', 'of', 'May', 0.0, 1, 2, 3, 4],\\n  [7, 11, 'lived', 229],\\n  ['and', 6, 3, 'scores', 'six', 100]\\n]\\n\\nfor i, r in enumerate(arr_vectors):\\n  Test.assert_equals(flatten(r), res_vectors[i])\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,5,1,5,3,2,5,2,0,5,4,2,2,2,5,3,4,5,4,4,1,3,2,1,5,4,1,2,4,2,0,5,5],\"rators\":[\"a777e8chPvJkY3tKa\",\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"vTfyrr4pGddp8rbXc\",\"mDWNyaaQ9hvPCRzSd\",\"gb9rvGus2Jv7bjZSs\",\"DbGqnKakhW4EJnLM5\",\"EMJ6uvBZkie429gdg\",\"DNGkwLuAzEACszkAx\",\"6428wKHtwKkFdvBs5\",\"tAF9Gf6PiGogbZuWs\",\"7ws5HaSof5kkoRwTM\",\"Jqk2uJZZxEv5wZFze\",\"d8qtzoLB264iP8tdY\",\"fSQSHjW3e72MrWxbD\",\"YyXcTjfNCoZ4wsLaB\",\"DPi9QGLctq2y76KuE\",\"iS5BrkGLzJyPK7nKt\",\"buX4mCQhtXCfBjeno\",\"eHcgvkTGsH7ZziqBo\",\"8sNv5PTHa7XQ8bNqR\",\"yod5YhKtPqw2GfG9B\",\"BMEud9eeJnPDC8A2k\",\"yjtdwc2AC4jA2RWtn\",\"gJYuGdkXEWWmGRLzu\",\"sFMXNMFryYLjHsjYj\",\"PH32cNxBjrK4a28sn\",\"J23RcmzbdtBbPCTjT\",\"2PufnQcsHsfymufX3\",\"suArq5BbSy7gD6xri\",\"T6iBEE2jp7f7iEF2P\",\"pnzfNatg3P32mMYQY\",\"s5M5RvgqR9BhB9JoC\"],\"total\":39,\"quality\":[]},\"flags\":0},\"summary\":\"The nesting of lists can be viewed indirectly as curves and barriers of the real data embedded in lists, thus, defeats the very purpose of directly accessing them thru indexes and slices. In this challenge, a function is required to flatten those curves (i.e. level, iron, compress, raze, topple) and expose those data as a single list and not as a list of lists\",\"tags\":[\"recursion\",\"arrays\"],\"timestamp\":{\"$date\":1595171790682},\"title\":\"Recursion: Flatten the Curves\",\"quality\":0,\"family\":[{\"_id\":\"5s8AXfbk4X2Dmimrk\",\"language\":\"java\"},{\"_id\":\"PQvuPYTZ5gGL4WYJo\",\"language\":\"javascript\"},{\"_id\":\"2nciiXZN4HCuNEmAi\",\"language\":\"python3\"}]}}"]