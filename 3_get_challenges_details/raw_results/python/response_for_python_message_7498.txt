a["{\"msg\":\"result\",\"id\":\"2454\",\"result\":{\"_id\":\"tNBgMoebvrhQ7ft6J\",\"author\":\"MyName\",\"authorId\":\"P7NmFbCJ5offXMRvB\",\"code\":\"def remainders(lst):\\n\\t\",\"difficulty\":4.545454545454546,\"quality\":0,\"editorId\":\"J74DckDe4qdcCTxfL\",\"familyId\":\"JAw9dC3fEMTxbSvf5\",\"instructions\":\"Create a function that finds a number _n_ so that _n mod y = x_,  given a list of _x-y pairs_, where (0 ≤ _n_ ≤ product of all _y_'s).\\n\\nThis challenge is related to the [Chinese Remainder Theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem), which states that there is one and only one integer _n_ that is congruent with a number of divisors (called _moduli_) and their remainders for _n_ so long as those moduli are coprime, where _n_ is comprised between 0 and the product of all moduli.\\n\\nFor example, there is only one value between 0 and 3 × 4 × 5 = 60 for _n_ so that:\\n- n mod 3 = 0\\n- n mod 4 = 3\\n- n mod 5 = 4\\n\\nHere, _n_ = 39 because 39 mod 3 = 0, 39 mod 4 = 3, and 39 mod 5 = 4, and 3 and 4 are coprime, and so are 3 and 5, and 4 and 5.  The numbers -21 and 99 would also be congruent with the moduli and remainders given, but we will not be considering those as they aren't in the range (0, 60).\\n\\nYour input will be a list with a number of tuples in the form `(remainder, modulo)` and the output should be a number _n_ congruent with those moduli and remainders.\\n\\n### Examples\\n```\\nremainders([(0, 3), (3, 4), (4, 5)]) ➞ 39\\n# 39 mod 3 = 0, 39 mod 4 = 3 and 39 mod 5 = 4\\n\\nremainders([(1, 2),  (8, 9)]) ➞ 17\\n# 17 mod 2 = 1 and 17 mod 9 = 8\\n\\nremainders([(0, 15), (7, 16), (2, 17)]) ➞ 2535\\n# 2535 mod 15 = 0, 2535 mod 16 = 7 and 2535 mod 17 = 2\\n```\\n\\n### Notes\\n- You don't need to check for co-primality. Assume all moduli in the input will be coprime.\\n- An input will be at least one tuple.\\n- Test cases will include large numbers (check for efficiency).\",\"isFree\":false,\"isHidden\":false,\"lab\":\"Test.assert_equals(remainders([(6, 10)]), 6)\\nTest.assert_equals(remainders([(0, 500)]), 0)\\nTest.assert_equals(remainders([(0, 3), (3, 4), (4, 5)]), 39)\\nTest.assert_equals(remainders([(1, 2),  (8, 9)]), 17)\\nTest.assert_equals(remainders([(0, 15), (7, 16), (2, 17)]), 2535)\\nTest.assert_equals(remainders([(4, 7), (2, 3), (2, 4), (3, 11), (8, 17)]), 1334)\\nTest.assert_equals(remainders([(7, 14), (15, 23), (3, 5)]), 1533)\\nTest.assert_equals(remainders([(26, 100), (523, 809)]), 54726)\\nTest.assert_equals(remainders([(2, 83), (845, 991), (166, 200)]), 1220766)\\nTest.assert_equals(remainders([(56, 79), (8, 9), (102, 169), (8, 10), (14, 49)]), 21215348)\\nTest.assert_equals(remainders([(8, 9), (2, 4), (1, 5), (0, 13), (40, 43), (0, 7), (1, 11), (5, 29)]), 145587806)\\nTest.assert_equals(remainders([(1, 3), (4, 5), (4, 13), (4, 43), (4, 7), (0, 2), (4, 29)]), 4)\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,4,5,5,5,1],\"quality\":[],\"rators\":[\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"vTfyrr4pGddp8rbXc\",\"dw39vy33ZbFLfCDwF\",\"iS5BrkGLzJyPK7nKt\",\"yjtdwc2AC4jA2RWtn\"],\"total\":7},\"flags\":0},\"summary\":\"Create a function that finds a number n so that n mod y = x,  given a list of x-y pairs, where (0 ≤ n ≤ product of all y's).\\n\\nThis challenge is related to the Chinese Remainder Theorem, which states that there is one and only one integer n that is congruent with a number of divisors (called moduli) and their remainders for n so long as those moduli are coprime\",\"tags\":[\"math\",\"numbers\",\"algorithms\"],\"timestamp\":{\"$date\":1600277963528},\"title\":\"Chinese Remainders\",\"family\":[{\"_id\":\"kGJZN2g4NeRAz2zKZ\",\"language\":\"cpp\"},{\"_id\":\"ZkYHTLivZgtn2SZwr\",\"language\":\"javascript\"},{\"_id\":\"tNBgMoebvrhQ7ft6J\",\"language\":\"python3\"},{\"_id\":\"wgtJGMRX2t7Zbghg3\",\"language\":\"ruby\"}]}}"]