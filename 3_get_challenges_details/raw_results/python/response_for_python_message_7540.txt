a["{\"msg\":\"result\",\"id\":\"2475\",\"result\":{\"_id\":\"PCuFMovzywF9D84Zx\",\"author\":\"Evgeny SH\",\"authorId\":\"8PwfYqoDQFThzNtvf\",\"code\":\"class Curve:\\n\\n    def __init__(self, knots):\\n        \\\"\\\"\\\"Input: list or set of tuples (x, y)\\n        For identical x computes average for y\\n        Sorts unique tuples\\n        Calls internal method that make splines\\n        \\\"\\\"\\\"\\n        dict_knots = dict()\\n        for tpl in knots:\\n            if tpl[0] in dict_knots:\\n                dict_knots[tpl[0]][0] += tpl[1]\\n                dict_knots[tpl[0]][1] += 1\\n            else:\\n                dict_knots[tpl[0]] = [tpl[1], 1]\\n        self.knots = sorted((key, val[0] / val[1])\\n                            for key, val in dict_knots.items())\\n        assert len(self.knots) >= 3\\n        self.n_knots = len(self.knots)\\n        self.sp = self.__make_splines__()\\n\\n    def __make_splines__(self):\\n        \\\"\\\"\\\"Return dictionary for n_knots-1 splines\\\"\\\"\\\"\\n        return {'n': n, 'a': a, 'b': b, 'c': c, 'd': d, 'x': x}\\n\\n    def value(self, x):\\n        \\\"\\\"\\\"Returns y for given x\\n        If x on the left of knots, first spline is used\\n        If x on the right of knots, last spline is used\\n        If x inside range of knots, finds the spline and computes y\\n        \\\"\\\"\\\"\\n        return \\n\\n    def add_knot(self, knot):\\n        \\\"\\\"\\\"Returns new object with updated list of knots\\n        For identical x, new y is averaged by constructor\\n        \\\"\\\"\\\"\\n        return \\n\\n    def remove_knot(self, knot):\\n        \\\"\\\"\\\"Returns new object with updated list of knots\\n        Remove only if both (x, y) are found\\n        n_knots cannot be less than 3\\n        \\\"\\\"\\\"\\n        if self.n_knots > 3:\\n            return \\n\\n    def __add__(self, other):\\n        \\\"\\\"\\\"Returns new object with updated list of knots\\\"\\\"\\\"\\n        return \\n\\n    def __sub__(self, other):\\n        \\\"\\\"\\\"Returns new object with updated list of knots\\n        knots of other are subtracted from knots of self\\n        \\\"\\\"\\\"\\n        return \\n\\n    def min_max(self):\\n        \\\"\\\"\\\"Returns tuple of 2 tuples (x_min, y_min), (x_max, y_max)\\n        y_min, y_max can be reached at knots or within a spline on the curve\\n        \\\"\\\"\\\"\\n        return \",\"difficulty\":4.75,\"editorId\":\"8PwfYqoDQFThzNtvf\",\"familyId\":\"hSCf5ms5EejfwrZwu\",\"instructions\":\"Cubic splines are used to smoothly connect the dots. Write implementation of the class `Curve` that:\\n\\n- Accepts a list or set of tuples `(x, y)`.\\n- Builds `n-1` splines for `n` unique knots.\\n- Computes `y` for given `x`.\\n- Finds `min` and `max` of the curve.\\n- Supports knot addition and removal.\\n- Supports overloaded operators `+`, `-`.\\n\\nMore detailed description of the class with names of methods is in the _docstrings_ in the Code window.\\n\\n### Examples\\nFor the given 6 lists of knots in Tests, the following curves are constructed:\\n\\n![Alternative Text](https://edabit-challenges.s3.amazonaws.com/Figure-6scaled.png)\\n\\n### Notes\\n- In practical usage of the splines `x` is inside the knots range, but in this challenge `x` can be anywhere to compute `y`.\\n- The minimum or maximum can lie either on a knot or somewhere inside if a spline bends. The search range is restricted to the range of knots; outside the curve goes to infinity.\\n- The algorithm for building splines is pretty straightforward and well explained in the wiki page: [Spline (mathematics)](https://en.wikipedia.org/wiki/Spline_(mathematics)#Algorithm_for_computing_natural_cubic_splines).\",\"isFree\":false,\"isHidden\":false,\"lab\":\"import time\\n\\nlst_knots = [\\n    [(1, 1), (1.5, 1), (2, 4), (2.5, 3), (3, 2), (3.5, 4), (4, 3)],\\n    [(1, 1), (2, 4), (3, 2), (4, 3)],\\n    [(-1, 0), (10, 3), (4, 1.5), (-1, 4), (1.5, 1), (3, 2)],\\n    [(-5, 0), (6, -1), (0, 2), (2, 4), (8, 3), (2, 2), (3, 2)],\\n    [(4, 4), (-4, 3), (2, 6), (-2, 6), (0, 6)],\\n    [(-2, 0), (0, -1), (2, 4), (2.5, 3), (3, 2), (4, 3)]\\n]\\n\\ntic = time.perf_counter()\\nlst_sp = [Curve(knots) for knots in lst_knots]\\nprint('Make 6 curves\\\\nruntime = {:.6f}\\\\n'.format(time.perf_counter() - tic))\\n\\n\\nlst_x = [2.2, 4.6, -3, -2.5, 4, -2]\\nlst_y = [4.068430769230769, 4.0352, 3.1431412103746394, 0.5996164259927798,\\n         4.0, 0.0]\\ntic = time.perf_counter()\\nfor i, x_val in enumerate(lst_x):\\n    Test.assert_equals(abs(lst_y[i] - lst_sp[i].value(x_val)) < 0.000000001, True)\\nprint('Compute 6 y_vals\\\\nruntime = {:.6f}\\\\n'.format(time.perf_counter() - tic))\\n\\nlst_min_max = [((1.2886751345948129, 0.5874659615021136),\\n                (2.1096984493010407, 4.157063477690783)),\\n               ((1, 1.0), (1.9927271762054324, 4.000242132531974)),\\n               ((0.9575200141235161, 0.8560448601421319), (10, 3.0)),\\n               ((5.617704864531077, -1.1279812580580901),\\n                (1.6986545353359912, 3.0598403375432843)),\\n               ((-4, 3.0), (-1.3010961023018706, 6.205359754330297)),\\n               ((-0.6463374738743516, -1.6567213006313906),\\n                (1.87261117785007, 4.053237076850908))]\\ntic = time.perf_counter()\\nfor i, x_val in enumerate(lst_x):\\n    tpl = lst_sp[i].min_max()\\n    Test.assert_equals((abs(lst_min_max[i][0][0] - tpl[0][0]) < 0.000000001 and\\n           abs(lst_min_max[i][0][1] - tpl[0][1]) < 0.000000001 and\\n           abs(lst_min_max[i][1][0] - tpl[1][0]) < 0.000000001 and\\n           abs(lst_min_max[i][1][1] - tpl[1][1]) < 0.000000001), True)\\nprint('Compute 6 min_max\\\\nruntime = {:.6f}\\\\n'.format(time.perf_counter() - tic))\\n\\ntic = time.perf_counter()\\nnew_curve = lst_sp[0].add_knot((3, 4))\\nTest.assert_equals(new_curve.n_knots, 7)\\nTest.assert_equals(new_curve.knots, [(1, 1.0), (1.5, 1.0), (2, 4.0), (2.5, 3.0),\\n                          (3, 3.0), (3.5, 4.0), (4, 3.0)])\\n\\nnew_curve = lst_sp[2].remove_knot((3, 2))\\nTest.assert_equals(new_curve.n_knots, 4)\\nTest.assert_equals(new_curve.knots, [(-1, 2.0), (1.5, 1.0), (4, 1.5), (10, 3.0)])\\n\\nnew_curve = lst_sp[0] - lst_sp[1]\\nTest.assert_equals(new_curve.n_knots, 3)\\nTest.assert_equals(new_curve.knots, [(1.5, 1.0), (2.5, 3.0), (3.5, 4.0)])\\n\\nnew_curve = lst_sp[3] + lst_sp[4]\\nTest.assert_equals(new_curve.n_knots, 9)\\nTest.assert_equals(new_curve.knots, [(-5, 0.0), (-4, 3.0), (-2, 6.0), (0, 4.0), (2, 4.5),\\n                          (3, 2.0), (4, 4.0), (6, -1.0), (8, 3.0)])\\nprint('Modify few curves\\\\nruntime = {:.6f}\\\\n'.format(time.perf_counter() - tic))\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,4,4],\"rators\":[\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"sfoAF6eygyfp6MWx3\"],\"total\":4,\"quality\":[]},\"flags\":0},\"summary\":\"Cubic splines are used to smoothly connect the dots. Write implementation of the class Curve that:\\n\\nAccepts a list or set of tuples (x, y).\\nBuilds n-1 splines for n unique knots.\\nComputes y for given x.\\nFinds min and max of the curve.\\nSupports knot addition and removal.\\nSupports overloaded operators +, -.\\n\\nMore detailed description of the class with names of m\",\"tags\":[\"math\",\"classes\",\"loops\",\"control_flow\"],\"timestamp\":{\"$date\":1591724081877},\"title\":\"Cubic Splines\",\"quality\":0,\"family\":[{\"_id\":\"PCuFMovzywF9D84Zx\",\"language\":\"python3\"}]}}"]