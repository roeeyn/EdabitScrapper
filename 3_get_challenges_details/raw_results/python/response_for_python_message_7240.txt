a["{\"msg\":\"result\",\"id\":\"2326\",\"result\":{\"_id\":\"SbXSM5HwdkgENLEwY\",\"author\":\"Evgeny SH\",\"authorId\":\"8PwfYqoDQFThzNtvf\",\"code\":\"class Selfie:\\n\\n    def __init__(self):\\n        self.lst_state = []\\n\\n    def save_state(self):\\n\\n    def recover_state(self, n):\\n\\n    def n_states(self):\\n\",\"difficulty\":3.7142857142857144,\"editorId\":\"8PwfYqoDQFThzNtvf\",\"familyId\":\"fntD8o9u3RCCpTSJK\",\"instructions\":\"Implement a class `Selfie` that can store the current state of the object in the form of binary string. It can take multiple pictures and then recover to a state it was before. During testing an object will be provided with new attributes and their values. It will store its state. Then the values will be changed. Then it will be given new attributes. It will store its state again. It will be repeated few times.\\n\\nLater the states of the object will be recovered given an index. The return value should be a new _Selfie_ with the requested historic state and the state history of the new object should be updated with a copy of current object's state history.\\n\\nThe object also knows how many states it has stored. If the index is not within the range of stored states, the object stays as is. If the argument is invalid, `n < 0 or n >= self.n_states()`, the current object (or a copy thereof) should be returned.\\n\\n### Examples\\n```\\np = Selfie()\\np.x = 2\\np.save_state()\\np.x = 5\\np = p.recover_state(0)\\np.x âžž 2\\n```\\n\\n### Notes\\n- Use of global variables outside the class is not allowed.\\n- When an object is restored to a previous state it keeps all saved states.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"from random import randint\\nimport time\\n\\nlst_test = [\\n    ({'x': 13, 'd1': {'a': 1, 'b': 4}, 's1': 'they like'},\\n     {'y': 11, 'd2': {'m': 15, 'n': 14}, 's2': 'where to'},\\n     {'z': 10, 'd3': {'intercept': 6.4, 'slope': 0.7}, 'tpl': (5, 7)}),\\n    ({'f': 1.6, 'l1': [1, 3, 5], 'l2': [24, 25]},\\n     {'my_tpl': (1, 1), 's1': 'we know', 's2': 'how to do it'}),\\n    ({'s1': 'laptop', 's2': 'has', 's3': 'screen and keyboard', 's4': '!'},\\n     {'a1': 11, 'a2': 13, 'a3': 17, 'a4': 19, 'a5': 23, 'a6': 29},\\n     {'l1': [1, 3, 5], 'l2': [24, 25], 'l3': [33], 'l4': [42, 44, 46, 48]},\\n     {'st1': {99, 88, 77}, 'tpl37': (3, 7), 'dct72': {'q': 12, 'w': 5}})\\n]\\n\\ntic = time.perf_counter()\\n\\np = Selfie()\\np.x = 2\\np.save_state()\\np.x = 5\\np = p.recover_state(0)\\nTest.assert_equals(p.x, 2)\\n\\nfor t in lst_test:\\n    p = Selfie()\\n    for d in t:\\n        s = p.lst_state.copy()\\n\\n        \\\"\\\"\\\"assign given attributes\\\"\\\"\\\"\\n        p.__dict__ = d.copy()\\n        p.__dict__.update({'lst_state': s})\\n\\n        p.save_state()\\n\\n        \\\"\\\"\\\"change the values of attributes\\\"\\\"\\\"\\n        for k in p.__dict__.keys():\\n            if k != 'lst_state':\\n                p.__dict__[k] = randint(0, 100)\\n\\n        \\\"\\\"\\\"check that the object is different now\\\"\\\"\\\"\\n        state_dict = p.__dict__.copy()\\n        del state_dict['lst_state']\\n        Test.assert_equals(state_dict != d, True)\\n\\n    \\\"\\\"\\\"check the number of saved states\\\"\\\"\\\"\\n    Test.assert_equals(p.n_states(), len(t))\\n\\n    \\\"\\\"\\\"check the type of stored states\\\"\\\"\\\"\\n    Test.assert_equals(all(type(val) == bytes for val in p.lst_state), True)\\n\\n    \\\"\\\"\\\"check the saved states\\\"\\\"\\\"\\n    for i, d in enumerate(t):\\n        p = eval(\\\"p.recover_state(i)\\\", {'p': p, 'i': i})\\n        state_dict = p.__dict__.copy()\\n        del state_dict['lst_state']\\n        Test.assert_equals(state_dict, d)\\n\\n    \\\"\\\"\\\"try to recover to incorrect index of saved states\\\"\\\"\\\"\\n    p = eval(\\\"p.recover_state(idx)\\\", {'p': p, 'idx': len(t) + randint(1, 10)})\\n    state_dict = p.__dict__.copy()\\n    del state_dict['lst_state']\\n    Test.assert_equals(state_dict, t[-1])\\n\\nprint('Runtime(sec) = {:.6f}'.format(time.perf_counter() - tic))\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,4,3,0,3,5,2,3,2],\"rators\":[\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"sfoAF6eygyfp6MWx3\",\"cykCKNJcqFBxz4T8s\",\"foytX6kH9wiSYqLtT\",\"xn7uGNKeAwPEkP9oA\",\"uznjMqKo6mzk5fsJh\",\"yjtdwc2AC4jA2RWtn\",\"e5tS8PDWAwdPcWT88\"],\"total\":9,\"quality\":[]},\"flags\":0},\"summary\":\"Implement a class Selfie that can store the current state of the object in the form of binary string. It can take multiple pictures and then recover to a state it was before. During testing an object will be provided with new attributes and their values. It will store its state. Then the values will be changed. Then it will be given new attributes. It will sto\",\"tags\":[\"classes\",\"objects\"],\"timestamp\":{\"$date\":1593907704919},\"title\":\"Class That Takes Selfies\",\"quality\":0,\"family\":[{\"_id\":\"SbXSM5HwdkgENLEwY\",\"language\":\"python3\"}]}}"]