a["{\"msg\":\"result\",\"id\":\"2465\",\"result\":{\"_id\":\"hL99axe3LyRGFWEjd\",\"author\":\"Evgeny SH\",\"authorId\":\"8PwfYqoDQFThzNtvf\",\"code\":\"def decor(func):\\n\\t\",\"difficulty\":4.666666666666667,\"editorId\":\"8PwfYqoDQFThzNtvf\",\"familyId\":\"bJZzSoSo87nyDF8P5\",\"instructions\":\"Functions in Python are first class citizens. This means that they support operations such as being passed as an argument, returned from a function, modified, and assigned to a variable.\\n\\nA decorator is a design pattern in Python that allows a user to add new functionality to an existing object without modifying its structure. Create a function decorator that wraps a function, making a new function with extended behavior. The input is a simple mathematical function `y(x)`. The output is a function `f(val, dict)` with the following properties:\\n\\n- If `val` is a single number then `f` returns `y(val)`.\\n- If `val` is a string equal to `\\\"length\\\" or \\\"area\\\"` then `f` returns a piece-wise linear approximation of the curve length or trapezoidal approximation of the area under the curve. The region for the curve length or area is provided in the dictionary (e.g. ` {\\\"begin\\\": -3, \\\"end\\\": 2, \\\"step\\\": 0.1}`).\\n- If `len(vals)` is not equal to one or if it is not a string `\\\"length\\\" or \\\"area\\\"` then `f` returns `None`.\\n\\n### Examples\\n```\\nf = decor(lambda x: x * x)\\nf() ➞ None\\nf(3) ➞ 9\\nf(3, 4) ➞ None\\nf(\\\"volume\\\", **{\\\"begin\\\": 0, \\\"end\\\": 2, \\\"step\\\": 0.001}) ➞ None\\nf(\\\"area\\\", **{\\\"begin\\\": 0, \\\"end\\\": 2, \\\"step\\\": 0.001}) ➞ 2.67\\n```\\n\\n### Notes\\n- No need to round the results, it’s done in the tests.\\n- The returned function `f` should accept positional and keyword arguments.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"import math\\nimport time\\ntic = time.perf_counter()\\n\\nf1 = decor(lambda x: x * x)\\nTest.assert_equals(f1(), None)\\nTest.assert_equals(f1(3), 9)\\nTest.assert_equals(f1(3, 4), None)\\nTest.assert_equals(f1('volume', **{'begin': 0, 'end': 2, 'step': 0.001}), None)\\n\\nlst_test = [\\n    (lambda x: x, 0.5, dict(), 0.5),\\n    (lambda x: x, 'length', {'begin': 0, 'end': 2, 'step': 0.001}, 2.83),\\n    (lambda x: x, 'area', {'begin': 0, 'end': 2, 'step': 0.001}, 2.0),\\n    (lambda x: x * x, 'area', {'begin': 0, 'end': 2, 'step': 0.001}, 2.67),\\n    (lambda x: math.sin(x), 'area', {'begin': -1, 'end': 1, 'step': 0.001},\\n     0.0),\\n    (lambda x: math.sin(x), 'length',\\n     {'begin': -math.pi / 2, 'end': math.pi / 2, 'step': 0.001}, 3.82),\\n    (lambda x: math.exp(x), 'area', {'begin': 0, 'end': 4, 'step': 0.0001},\\n     53.6),\\n    (lambda x: math.exp(x), 'length', {'begin': -3, 'end': 3, 'step': 0.0001},\\n     22.75),\\n    (lambda x: 4 + math.exp(x), 1, dict(), 6.72),\\n    (lambda x: 1.5, 'length', {'begin': -3, 'end': 2, 'step': 0.1}, 5.0),\\n    (lambda x: 1.5, 'area', {'begin': -3, 'end': 2, 'step': 0.1}, 7.5),\\n]\\n\\nfor tpl in lst_test:\\n    f = decor(tpl[0])\\n    Test.assert_equals(round(f(tpl[1], **tpl[2]), 2), tpl[3])\\n\\nprint('Runtime(sec) = {:.6f}'.format(time.perf_counter() - tic))\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,4,5,4,3,5,5],\"rators\":[\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"d6iEb2BDDofyeePh9\",\"eHcgvkTGsH7ZziqBo\",\"yjtdwc2AC4jA2RWtn\",\"iS5BrkGLzJyPK7nKt\",\"s5M5RvgqR9BhB9JoC\"],\"total\":7,\"quality\":[]},\"flags\":0},\"summary\":\"Functions in Python are first class citizens. This means that they support operations such as being passed as an argument, returned from a function, modified, and assigned to a variable.\\n\\nA decorator is a design pattern in Python that allows a user to add new functionality to an existing object without modifying its structure. Create a function decorator that\",\"tags\":[\"functional_programming\",\"math\"],\"timestamp\":{\"$date\":1593527203114},\"title\":\"Function Decorator\",\"quality\":0,\"family\":[{\"_id\":\"hL99axe3LyRGFWEjd\",\"language\":\"python3\"}]}}"]