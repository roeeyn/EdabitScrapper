a["{\"msg\":\"result\",\"id\":\"2427\",\"result\":{\"_id\":\"zpxHSwZJTpasGtwbb\",\"author\":\"Evgeny SH\",\"authorId\":\"8PwfYqoDQFThzNtvf\",\"code\":\"user_name = \\\"your string\\\"\",\"difficulty\":4.3,\"editorId\":\"8PwfYqoDQFThzNtvf\",\"familyId\":\"67yj2gE4yM9pYGviZ\",\"instructions\":\"The bookstore from [this collection]( https://edabit.com/collection/dnXtkLPZpX25t227q) is adamant in using `eval()`, but has moved the users dictionary into a class to prevent copying. The `check_a_user(name)` function returns entries in users which match a given username. Create a query that copies users to res.\\n\\n### Examples\\n```\\nres = eval(\\\"check_a_user({})\\\".format(user_name),\\n           {'check_a_user': check_a_user})\\n\\nprint(res) âžž clients.all_users(control_num)\\n```\\n\\n### Notes\\nCreate a string, not a function.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"from random import randint, seed\\nimport time\\ntic = time.perf_counter()\\n\\nclass DB:\\n\\n    n_calls = 0\\n\\n    def __init__(self, n, control, len_word=15, len_pwd=17):\\n        DB.n_calls += 1\\n        self.n = n\\n        self.__ctrl = control\\n        self.len_word = len_word\\n        self.len_pwd = len_pwd\\n        self.__users = self.__make_users(len_word, len_pwd)\\n\\n    def __make_users(self, len_word, len_pwd):\\n        d = {''.join(chr(randint(33, 126)) for _ in range(len_word)):\\n             ''.join(chr(randint(33, 126)) for _ in range(len_pwd))\\n             for _ in range(self.n)}\\n        d.update({'a_name': 'a_pwd'})\\n        self.n += 1\\n        return d\\n\\n    def all_users(self, control_num):\\n        return (self.__users if DB.n_calls + self.__ctrl == control_num else\\n                self.__make_users(self.len_word, self.len_pwd))\\n\\n    def check_user(self, name):\\n        if name in self.__users:\\n            return {name: self.__users[name]}\\n        else:\\n            return {name: 'not found'}\\n\\nfor i in range(1, 21):\\n    seed()\\n    len_dict = randint(3, 13)\\n    ctrl = randint(-100, 100)\\n    clients = DB(len_dict, ctrl)\\n\\n    def check_a_user(name, db=clients):\\n        return db.check_user(name)\\n\\n    res = eval(\\\"check_a_user({})\\\".format(user_name),\\n               {'check_a_user': check_a_user})\\n\\n    if isinstance(res, dict) and len(res) == len_dict + 1:\\n        Test.assert_equals(res, clients.all_users(i + ctrl))\\n    else:\\n        print('\\\"res\\\" is not a dictionary of the correct length')\\n        print('res = {}'.format(res))\\n        Test.assert_equals(True, False)\\n\\nprint('Runtime(sec) = {:.9f}'.format(time.perf_counter() - tic))\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,5,1,4,3],\"rators\":[\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"yv7c4H2jimSKHEjtG\",\"wNc5vZ22fiYCgnwxe\",\"yjtdwc2AC4jA2RWtn\"],\"total\":5,\"quality\":[]},\"flags\":0},\"summary\":\"The bookstore from this collection is adamant in using eval(), but has moved the users dictionary into a class to prevent copying. The checkauser(name) function returns entries in users which match a given username. Create a query that copies users to res.\\n\\nExamples\\nres = eval(\\\"checkauser({})\\\".format(user_name),\\n           {'checkauser': checkauser})\\n\\nprint(re\",\"tags\":[\"classes\",\"data_structures\",\"games\",\"logic\"],\"timestamp\":{\"$date\":1593383501518},\"title\":\"Injection IV.E: Inside the Class\",\"quality\":0,\"family\":[{\"_id\":\"zpxHSwZJTpasGtwbb\",\"language\":\"python3\"}]}}"]