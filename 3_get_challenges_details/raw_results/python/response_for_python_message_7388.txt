a["{\"msg\":\"result\",\"id\":\"2399\",\"result\":{\"_id\":\"xTKQ3zYZ7gY7fBpr9\",\"author\":\"kmm012\",\"authorId\":\"d6iEb2BDDofyeePh9\",\"code\":\"def how_many_paths(lst):\\n\\t\",\"difficulty\":4,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"5uipqCiz4fGYq3Pii\",\"instructions\":\"This challenge is an extension of Helen Yu's  [Can You Exit the Maze?](https://edabit.com/challenge/ogDHjfpAcE896kN4H) and [Can You Enter the Cave?](https://edabit.com/challenge/CP5zy4iLZzNy2KFcN). Most of the test cases come from her challenge with a few new ones of my own.\\n\\nInstead of finding a path through the maze, you must find all connected paths - paths where you can walk from one cell to another either by doing up or down or left or right. Not diagonally.\\n\\nThe maze is represented by a 2D matrix, where 0s represent walkable areas, and 1s represents walls.\\n\\nWrite a function that will return the length of the longest connected path (each cell only counts once even if you must re-enter to fully walk the path) and the number of connected paths as a tuple.\\n\\n### Examples\\n```\\nhow_many_paths([\\n  [0, 0, 0, 1, 0, 0, 1, 1],\\n  [0, 1, 0, 1, 0, 0, 0, 1],\\n  [0, 0, 0, 1, 1, 1, 1, 1],\\n  [1, 1, 1, 1, 0, 0, 0, 1],\\n  [1, 0, 1, 1, 0, 0, 0, 1],\\n  [1, 1, 1, 1, 0, 0, 0, 1]\\n]) ➞ (9, 4)\\n\\n# The longest path is in the lower right and there are\\n# four paths, upper left with 8, upper right with 5,\\n# lower left with 1.\\n```\\n\\n```\\nhow_many_paths([\\n  [0, 1, 1, 1, 1, 1, 1, 0],\\n  [0, 0, 0, 0, 0, 0, 0, 0],\\n  [0, 0, 0, 0, 0, 1, 1, 0],\\n  [0, 1, 1, 0, 0, 1, 1, 0]\\n]) ➞ (20, 1)\\n```\\n\\n```\\nhow_many_paths([\\n  [0, 1, 1, 1, 0, 1, 1, 0],\\n  [0, 0, 1, 1, 0, 0, 0, 0],\\n  [0, 0, 0, 0, 1, 1, 1, 0],\\n  [0, 1, 1, 1, 1, 1, 1, 0]\\n]) ➞ (8, 2)\\n```\\n\\n### Notes\\nThis is a variation of a problem where I had to find all groups of connected customers (owners of the same account) across a bank's customer database in preparation to split the bank and 'sell' off some of the customers/accounts.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"Test.assert_equals(how_many_paths([\\n\\t[0, 0, 1, 1, 1, 0, 0, 0], \\n\\t[0, 0, 0, 0, 1, 0, 0, 0], \\n\\t[0, 0, 1, 0, 0, 0, 0, 0], \\n\\t[0, 0, 1, 1, 1, 1, 1, 0]\\n]), (22, 1))\\n\\nTest.assert_equals(how_many_paths([\\n\\t[0, 0, 0, 1, 0, 0, 0, 0], \\n\\t[0, 0, 0, 1, 1, 0, 0, 0], \\n\\t[0, 0, 0, 0, 1, 1, 0, 0], \\n\\t[0, 0, 0, 1, 1, 1, 1, 0]\\n]), (13, 2))\\n\\nTest.assert_equals(how_many_paths([\\n\\t[0, 1, 1, 1, 0, 1, 1, 0], \\n\\t[0, 0, 1, 1, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 0, 1, 0, 0], \\n\\t[0, 1, 1, 1, 1, 1, 1, 0]\\n]), (18, 1))\\n\\nTest.assert_equals(how_many_paths([\\n\\t[0, 1, 1, 1, 0, 1, 1, 0], \\n\\t[0, 0, 1, 1, 0, 0, 0, 0], \\n\\t[0, 0, 0, 1, 0, 1, 0, 0], \\n\\t[0, 1, 1, 1, 1, 1, 1, 0]\\n]), (10, 2))\\n\\nTest.assert_equals(how_many_paths([\\n\\t[0, 1, 1, 1, 0, 1, 1, 0], \\n\\t[0, 0, 1, 1, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 1, 1, 1, 0], \\n\\t[0, 1, 1, 1, 1, 1, 1, 0]\\n]), (8, 2))\\n\\nTest.assert_equals(how_many_paths([\\n\\t[0, 1, 1, 1, 1, 1, 1, 0], \\n\\t[0, 0, 0, 0, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 0, 1, 1, 0], \\n\\t[0, 1, 1, 0, 0, 1, 1, 0]\\n]), (20, 1))\\n\\nTest.assert_equals(how_many_paths([\\n\\t[0, 1, 1, 1, 1, 1, 1, 0], \\n\\t[0, 0, 0, 0, 1, 0, 0, 0], \\n\\t[0, 0, 1, 1, 1, 1, 1, 0], \\n\\t[0, 1, 1, 0, 0, 1, 1, 0]\\n]), (8, 3))\\n\\nTest.assert_equals(how_many_paths([\\n\\t[0, 1, 1, 1, 1, 1, 1, 0], \\n\\t[0, 1, 0, 0, 1, 0, 0, 0], \\n\\t[0, 0, 1, 0, 1, 1, 1, 0], \\n\\t[0, 1, 1, 0, 0, 1, 1, 0]\\n]), (6, 3))\\n\\nTest.assert_equals(how_many_paths([\\n\\t[0, 1, 1, 1, 1, 1, 1, 1], \\n\\t[0, 0, 0, 0, 1, 0, 0, 1], \\n\\t[0, 0, 1, 0, 1, 0, 0, 0], \\n\\t[0, 1, 1, 0, 0, 0, 1, 0]\\n]), (18, 1))\\n\\nTest.assert_equals(how_many_paths([\\n\\t[1, 0, 0, 0, 0, 0, 1, 0, 0], \\n\\t[1, 0, 1, 1, 1, 0, 1, 0, 1], \\n\\t[1, 0, 1, 0, 0, 0, 1, 0, 1], \\n\\t[1, 0, 1, 0, 1, 1, 1, 0, 1],\\n\\t[0, 0, 1, 0, 0, 0, 0, 0, 1]\\n]), (25, 1))\\n\\nTest.assert_equals(how_many_paths([\\n\\t[1, 1, 1, 1, 1, 1, 1, 1], \\n\\t[1, 1, 1, 1, 1, 1, 1, 1], \\n\\t[1, 1, 1, 1, 1, 1, 1, 1], \\n\\t[1, 1, 1, 1, 1, 1, 1, 1]\\n]), (0, 0))\\n\\n\\nTest.assert_equals(how_many_paths([\\n\\t[0, 0, 0, 0, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 0, 0, 0, 0]\\n]), (32, 1))\\n\\nTest.assert_equals(how_many_paths([\\n\\t[0, 0, 0, 1, 0, 0, 1, 1],\\n\\t[0, 1, 0, 1, 0, 0, 0, 1],\\n\\t[0, 0, 0, 1, 1, 1, 1, 1],\\n\\t[1, 1, 1, 1, 0, 0, 0, 1],\\n\\t[1, 0, 1, 1, 0, 0, 0, 1],\\n\\t[1, 1, 1, 1, 0, 0, 0, 1]\\n]), (9, 4))\",\"language\":\"python3\",\"quality\":0,\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,5,4,0,5,5,5,1,1,5,3],\"quality\":[],\"rators\":[\"d6iEb2BDDofyeePh9\",\"8PwfYqoDQFThzNtvf\",\"mDWNyaaQ9hvPCRzSd\",\"aEm3Wvj2rFYRL8Lrb\",\"s5M5RvgqR9BhB9JoC\",\"iS5BrkGLzJyPK7nKt\",\"yod5YhKtPqw2GfG9B\",\"yjtdwc2AC4jA2RWtn\",\"8sNv5PTHa7XQ8bNqR\",\"gJYuGdkXEWWmGRLzu\",\"eHcgvkTGsH7ZziqBo\"],\"total\":12},\"flags\":0},\"summary\":\"This challenge is an extension of Helen Yu's  Can You Exit the Maze? and Can You Enter the Cave?. Most of the test cases come from her challenge with a few new ones of my own.\\n\\nInstead of finding a path through the maze, you must find all connected paths - paths where you can walk from one cell to another either by doing up or down or left or right. Not diagon\",\"tags\":[\"functional_programming\",\"arrays\"],\"timestamp\":{\"$date\":1607457967838},\"title\":\"How Many Paths?\",\"family\":[{\"_id\":\"DLc7xPX2LRrHZB5H9\",\"language\":\"cpp\"},{\"_id\":\"JDrFEafj2647uv9Ey\",\"language\":\"javascript\"},{\"_id\":\"xTKQ3zYZ7gY7fBpr9\",\"language\":\"python3\"},{\"_id\":\"ezp4q7C7Rqmp2euAe\",\"language\":\"ruby\"}]}}"]