a["{\"msg\":\"result\",\"id\":\"2498\",\"result\":{\"_id\":\"6hfKCpeH2jL6QSDGT\",\"author\":\"Evgeny SH\",\"authorId\":\"8PwfYqoDQFThzNtvf\",\"code\":\"def count_shapes(m):\\n\\t\",\"difficulty\":5,\"quality\":0,\"editorId\":\"8PwfYqoDQFThzNtvf\",\"familyId\":\"dwRxETKRZmTtT2kzW\",\"instructions\":\"Write a function that counts the number of separate elements in the region.\\n\\n### Input\\nA rectangular matrix, list of lists, with zero/one in each cell. A connected element is a collection of ones that share the border via an edge. Separate elements do not touch each other even via a corner. The elements don’t have holes.\\n\\n### Output\\nThe number of separate elements.\\n\\n### Examples\\n```\\nregion = [\\n  [0, 0, 0, 0, 0, 0, 0],\\n  [0, 0, 1, 0, 1, 1, 0],\\n  [0, 1, 1, 0, 1, 0, 0],\\n  [0, 0, 0, 0, 1, 1, 0],\\n  [0, 1, 1, 0, 1, 1, 0],\\n  [0, 0, 0, 0, 0, 0, 0],\\n]\\n\\ncount_shapes(region) ➞ 3\\n```\\n\\n### Notes\\n- How to locate different elements can be learned from the [Chain Reaction]( https://edabit.com/collection/gSLJ6kGBAXEg2P4sH) series.\\n- It takes up to 4 seconds to assemble the input regions in the tests. Solutions with _O(rows * columns)_ complexity allow us to pass the tests in the remaining 8 seconds (3.5 seconds is enough).\\n- The main goal of this challenge is to come up with an efficient solution.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"from random import randint\\nfrom time import perf_counter\\ntic_0 = perf_counter()\\n\\nregion = [\\n    [0, 0, 0, 0, 0, 0, 0],\\n    [0, 0, 1, 0, 1, 1, 0],\\n    [0, 1, 1, 0, 1, 0, 0],\\n    [0, 0, 0, 0, 1, 1, 0],\\n    [0, 1, 1, 0, 1, 1, 0],\\n    [0, 0, 0, 0, 0, 0, 0],\\n]\\ntic = perf_counter()\\nTest.assert_equals(count_shapes(region), 3)\\nprint('Test Time = {:.6f}'.format(perf_counter() - tic))\\n\\nparts = [\\n    [[0] * 10 for _ in range(10)],\\n    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],\\n     [0, 1, 0, 0, 0, 0, 0, 1, 1, 0],\\n     [0, 1, 0, 0, 0, 1, 0, 1, 1, 0],\\n     [0, 1, 1, 1, 1, 1, 0, 0, 0, 0],\\n     [0, 1, 1, 1, 1, 1, 0, 0, 0, 0],\\n     [0, 1, 0, 0, 0, 1, 0, 1, 1, 0],\\n     [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],\\n     [0, 1, 1, 1, 1, 1, 1, 1, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\\n    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 0, 0, 1, 1, 1, 1, 1, 0],\\n     [0, 1, 1, 0, 0, 1, 1, 1, 1, 0],\\n     [0, 1, 1, 1, 0, 0, 1, 1, 1, 0],\\n     [0, 1, 1, 1, 0, 0, 1, 1, 0, 0],\\n     [0, 1, 1, 1, 1, 0, 1, 1, 1, 0],\\n     [0, 1, 1, 1, 1, 0, 1, 1, 1, 0],\\n     [0, 1, 1, 1, 1, 0, 0, 1, 1, 0],\\n     [0, 1, 1, 1, 1, 1, 0, 0, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\\n    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 0, 1, 1, 1, 1, 1, 1, 0],\\n     [0, 1, 0, 0, 0, 0, 0, 1, 1, 0],\\n     [0, 1, 0, 1, 0, 1, 0, 1, 0, 0],\\n     [0, 1, 0, 1, 1, 1, 0, 1, 1, 0],\\n     [0, 1, 0, 1, 1, 1, 0, 0, 1, 0],\\n     [0, 1, 0, 0, 0, 1, 1, 0, 1, 0],\\n     [0, 1, 1, 0, 0, 0, 0, 0, 1, 0],\\n     [0, 1, 1, 1, 1, 0, 1, 1, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\\n    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 0, 1, 0, 0, 1, 1, 1, 1, 0],\\n     [0, 1, 1, 1, 0, 0, 1, 1, 1, 0],\\n     [0, 0, 1, 1, 0, 0, 0, 1, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\\n     [0, 1, 0, 0, 1, 0, 1, 0, 0, 0],\\n     [0, 1, 1, 0, 1, 1, 1, 1, 0, 0],\\n     [0, 1, 1, 0, 0, 0, 1, 1, 1, 0],\\n     [0, 1, 1, 1, 1, 0, 1, 1, 0, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\\n    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 1, 0, 1, 0, 1, 1, 1, 0],\\n     [0, 0, 1, 0, 1, 0, 1, 0, 1, 0],\\n     [0, 0, 1, 0, 1, 0, 0, 0, 1, 0],\\n     [0, 1, 1, 0, 1, 1, 0, 0, 0, 0],\\n     [0, 0, 0, 0, 0, 1, 0, 1, 0, 0],\\n     [0, 1, 1, 1, 0, 1, 0, 1, 0, 0],\\n     [0, 0, 1, 1, 0, 1, 0, 1, 1, 0],\\n     [0, 1, 1, 1, 0, 1, 0, 1, 0, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\\n    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 1, 1, 0, 1, 1, 1, 1, 0],\\n     [0, 0, 1, 1, 0, 0, 0, 1, 1, 0],\\n     [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\\n     [0, 0, 1, 0, 0, 1, 1, 1, 1, 0],\\n     [0, 1, 1, 1, 0, 1, 1, 1, 0, 0],\\n     [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\\n     [0, 0, 0, 0, 1, 0, 0, 0, 1, 0],\\n     [0, 1, 1, 1, 1, 0, 1, 1, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\\n    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 1, 0, 1, 1, 1, 0, 1, 0],\\n     [0, 0, 1, 0, 0, 1, 1, 0, 1, 0],\\n     [0, 0, 0, 0, 1, 1, 1, 0, 1, 0],\\n     [0, 1, 1, 0, 0, 0, 1, 1, 1, 0],\\n     [0, 1, 0, 0, 1, 0, 0, 0, 0, 0],\\n     [0, 0, 0, 1, 1, 0, 1, 1, 1, 0],\\n     [0, 1, 0, 0, 0, 0, 0, 0, 1, 0],\\n     [0, 1, 1, 1, 0, 1, 1, 0, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\\n    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],\\n     [0, 1, 1, 0, 0, 1, 0, 1, 0, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 1, 1, 1, 0, 1, 1, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 1, 1, 0, 1, 1, 1, 1, 0],\\n     [0, 1, 1, 0, 0, 0, 0, 1, 1, 0],\\n     [0, 1, 0, 0, 1, 1, 0, 1, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\\n    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 1, 0, 1, 0, 1, 1, 1, 0],\\n     [0, 1, 0, 0, 1, 0, 1, 0, 1, 0],\\n     [0, 1, 0, 1, 1, 0, 0, 0, 0, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\\n     [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 1, 0, 1, 0, 0, 1, 0, 0],\\n     [0, 1, 0, 0, 1, 0, 1, 1, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],\\n    [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\\n     [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],\\n     [0, 1, 0, 1, 1, 0, 1, 0, 0, 0],\\n     [0, 1, 0, 0, 0, 0, 0, 0, 1, 0],\\n     [0, 0, 0, 1, 1, 0, 1, 0, 1, 0],\\n     [0, 1, 0, 0, 1, 0, 1, 0, 1, 0],\\n     [0, 1, 1, 0, 1, 0, 1, 0, 0, 0],\\n     [0, 1, 1, 0, 1, 0, 1, 1, 1, 0],\\n     [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]\\n]\\n\\ntests_time = 0\\nfor k in range(100, 109):\\n    \\\"\\\"\\\"Randomly assemble the matrix from parts\\\"\\\"\\\"\\n    mat = []\\n    count_pieces = 0\\n    for row in range(k):\\n        mat += [[] for _ in range(10)]\\n        for col in range(k):\\n            idx_p = randint(0, 10)\\n            count_pieces += idx_p\\n            p = parts[idx_p].copy()\\n            \\\"\\\"\\\"Rotate the part\\\"\\\"\\\"\\n            for _ in range(randint(0, 3)):\\n                p = [list(col)[::-1] for col in zip(*p)]\\n            for r in range(10):\\n                mat[10 * row + r] += p[r]\\n    tic = perf_counter()\\n    Test.assert_equals(count_shapes(mat), count_pieces)\\n    t_time = perf_counter() - tic\\n    tests_time += t_time\\n    print('Test_{} Time = {:.6f}'.format(k, t_time))\\n\\nprint('\\\\nTotal Test Time = {:.3f}'.format(tests_time))\\nprint('Total Time = {:.3f}'.format(perf_counter() - tic_0))\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,5,5,5],\"quality\":[],\"rators\":[\"eHcgvkTGsH7ZziqBo\",\"vTfyrr4pGddp8rbXc\",\"iS5BrkGLzJyPK7nKt\",\"s5M5RvgqR9BhB9JoC\"],\"total\":6},\"flags\":0},\"summary\":\"Write a function that counts the number of separate elements in the region.\\n\\nInput\\nA rectangular matrix, list of lists, with zero/one in each cell. A connected element is a collection of ones that share the border via an edge. Separate elements do not touch each other even via a corner. The elements don’t have holes.\\n\\nOutput\\nThe number of separate elements.\\n\\nE\",\"tags\":[\"algorithms\",\"arrays\",\"loops\",\"math\"],\"timestamp\":{\"$date\":1599690956597},\"title\":\"Count Elements\",\"family\":[{\"_id\":\"6hfKCpeH2jL6QSDGT\",\"language\":\"python3\"}]}}"]