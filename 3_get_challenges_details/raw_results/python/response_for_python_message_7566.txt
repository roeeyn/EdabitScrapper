a["{\"msg\":\"result\",\"id\":\"2488\",\"result\":{\"_id\":\"NNyQBoYDMa3ER8cjs\",\"author\":\"Evgeny SH\",\"authorId\":\"8PwfYqoDQFThzNtvf\",\"code\":\"import numpy as np\\nclass Route:\\n\\n    def __init__(self, **kwargs):\\n        self.v_cruise = kwargs['cruising_speed']\\n        self.a = kwargs['acceleration']\\n        self.d = kwargs['deceleration']\\n        self.intervals = kwargs['intervals']\\n        self.lights_cycle = kwargs['lights_cycle']\\n        self.n_simulations = kwargs['n_simulations']\\n\\n    def interval(self, v0, length, time_to_green):\\n        \\\"\\\"\\\"computes interval travel time and exit speed (t, v)\\\"\\\"\\\"\\n        return (time_to_accelerate + time_to_cruise + decelerate_time\\n                + time_to_accelerate2, speed_at_finish)\\n\\n    def path(self, lengths, lst_time_to_green):\\n        \\\"\\\"\\\"computes total travel time through path\\\"\\\"\\\"\\n        return total_time\\n\\n    def simulate(self):\\n        \\\"\\\"\\\"computes array of path times[] n_simulations times\\n        returns triple: (np.average(times), low, high)\\n        low, high = np.percentile(times, [5, 95])\\n        \\\"\\\"\\\"\\n        return \",\"difficulty\":4.875,\"editorId\":\"8PwfYqoDQFThzNtvf\",\"familyId\":\"9KLXZYoTiG4drdKpa\",\"instructions\":\"A self-driven electric car needs to make a delivery from _point A_ to _point B_. The path consists of intervals with a traffic light at the end of each interval. Before the journey, the car calculates the `expected`, `lucky`, `unlucky` time travel estimates and uploads this information to the server.\\n\\nTravel through an interval can be modeled as having these parts:\\n- Initial acceleration. The speed at `t = 0` can be zero or any value less than cruising speed coming from the previous interval. The car accelerates to the cruising speed. If it is already at cruising speed, then it does not need to accelerate.\\n- Cruising distance. The car travels at constant speed until the decision point. Stoppage distance is the length required for the car to drop its speed from cruising speed to zero. Decision point is at the end of interval minus the stoppage distance.\\n- Deceleration. If the light is yellow or red, the car starts dropping the speed.\\n- Second acceleration. If the light suddenly turns green before the car is completely stopped, it accelerates and exits the interval with some speed.\\n\\nIf the light is green at the decision point, the car does not decelerate. It procced and exits the interval with cruising speed. If the light is yellow or red, the car stops at the end of the interval and continues to wait until the lights turns green. It enters the next interval with speed equal zero.\\n\\nThe traffic lights are modeled as a random number from the inclusive interval e.g. `(-59, 70)`. If the number is `<= 0`, the light is green. A positive number represents a number of seconds when the lights turn green after the car passes the decision point. For example if `time_to_green == 2`, the car will decelerate for 2 seconds, then switch to accelerating; if `time_to_green == 50`, the car will decelerate, stop and wait until 50 seconds pass since the decision point, then enters next interval with zero speed.\\n\\nTravel through the path is summation of travels through connected intervals. It can enter the next interval with non-zero speed if got lucky with the light. At the last interval `time_to_green == stoppage_time`, not random! In this way itâ€™s guaranteed that the car arrived at the end of the path and stopped.\\n\\nWrite the implementation of the `class Route`. It receives a dictionary with parameters of the car, intervals, lights cycle, and number of simulations. Description of three required methods is in the Code window. Per each simulation randomly generate n-1 `time_to_green` numbers to model the traffic lights, last interval has defined `time_to_green`.\\n\\nAfter having a sample of travel `times` compute: average, 5-percentile (lucky), 95-percentile (unlucky) of the sample.\\n\\n### Examples\\nTests have distributions of travel times similar to as depicted here:\\n![Alternative Text](https://edabit-challenges.s3.amazonaws.com/Figure-Expected-Time-Travel.png)\\n\\n### Notes\\n- Uniform or constant acceleration is computed by [this equation](https://en.wikipedia.org/wiki/Acceleration).\\n- The intervals are long enough such that the car always has time to reach the cruising speed and travel to the decision point.\\n- All tests runs within 2-3 seconds on the server.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"import time\\n\\nparameters = [{\\n    'cruising_speed': 20, 'acceleration': 2, 'deceleration': -4,\\n    'intervals': [1500, 900, 650, 1200, 800, 700, 1250],\\n    'lights_cycle': (-59, 70), 'n_simulations': 10000}, {\\n    'cruising_speed': 30, 'acceleration': 5, 'deceleration': -6,\\n    'intervals': [850, 900, 1900, 1200, 800, 1050, 1750, 1550],\\n    'lights_cycle': (-49, 60), 'n_simulations': 10000}, {\\n    'cruising_speed': 24, 'acceleration': 4, 'deceleration': -6,\\n    'intervals': [750, 900, 1500, 1200, 800, 1050, 1350, 1450],\\n    'lights_cycle': (-54, 65), 'n_simulations': 10000}\\n]\\n\\ntic = time.perf_counter()\\nrt = [Route(**parameters[i]) for i in range(len(parameters))]\\n\\ninterval_test = [(45.0, 0), (33.75, 30), (28.873, 15.4919)]\\ninterval_time_speed = rt[0].interval(0, 750, 5)\\n\\\"\\\"\\\"\\nt =  0.00, x =   0.00, v =  0.00\\nt = 10.00, x = 100.00, v = 20.00\\nt = 40.00, x = 700.00, v = 20.00\\nt = 45.00, x = 750.00, v =  0.00\\n\\\"\\\"\\\"\\nTest.assert_equals(interval_time_speed, interval_test[0])\\n\\ninterval_time_speed = rt[1].interval(15, 990, -5)\\n\\\"\\\"\\\"\\nt =  0.00, x =   0.00, v = 15.00\\nt =  3.00, x =  67.50, v = 30.00\\nt = 31.25, x = 915.00, v = 30.00\\nt = 33.75, x = 990.00, v = 30.00\\n\\\"\\\"\\\"\\nTest.assert_equals(interval_time_speed, interval_test[1])\\n\\ninterval_time_speed = rt[2].interval(0, 600, 2)\\n\\\"\\\"\\\"\\nt =  0.00, x =   0.00, v =  0.00\\nt =  6.00, x =  72.00, v = 24.00\\nt = 26.00, x = 552.00, v = 24.00\\nt = 28.00, x = 588.00, v = 12.00\\nt = 28.87, x = 600.00, v = 15.49\\n\\\"\\\"\\\"\\nt, s = round(interval_time_speed[0], 4), round(interval_time_speed[1], 4)\\nTest.assert_equals((t, s), interval_test[2])\\n\\npath_test = [401.8, 387.83, 438.25]\\npath_time = rt[0].path(rt[0].intervals, [10, -15, 4, 15, 0, 7])\\nTest.assert_equals(round(path_time, 2), path_test[0])\\n\\npath_time = rt[1].path(rt[1].intervals, [-10, 25, 5, 3, 0, 4, 12])\\nTest.assert_equals(round(path_time, 2), path_test[1])\\n\\npath_time = rt[2].path(rt[2].intervals, [0, 2, 11, 20, -10, 4, 18])\\nTest.assert_equals(round(path_time, 2), path_test[2])\\n\\nsimulation_test = [(477.4081, 386.1851, 578.5378),\\n                   (454.0556, 372.7417, 544.5194),\\n                   (505.9245, 417.1862, 604.5963)]\\n\\nfor i in range(len(parameters)):\\n    avg_time, low_time, high_time = rt[i].simulate()\\n    avg_test, low_test, high_test = simulation_test[i]\\n    Test.assert_equals(abs(avg_time - avg_test) / avg_test < 0.05 and\\n          abs(low_time - low_test) / low_test < 0.05 and\\n          abs(high_time - high_test) / high_test < 0.05, True)\\n\\nprint('t_simulation = {:.6f}'.format(time.perf_counter() - tic))\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,4,5],\"rators\":[\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"sfoAF6eygyfp6MWx3\"],\"total\":3,\"quality\":[]},\"flags\":0},\"summary\":\"A self-driven electric car needs to make a delivery from point A to point B. The path consists of intervals with a traffic light at the end of each interval. Before the journey, the car calculates the expected, lucky, unlucky time travel estimates and uploads this information to the server.\\n\\nTravel through an interval can be modeled as having these parts:\\nInit\",\"tags\":[\"classes\",\"loops\",\"math\"],\"timestamp\":{\"$date\":1592251477730},\"title\":\"Expected Travel Time\",\"quality\":0,\"family\":[{\"_id\":\"NNyQBoYDMa3ER8cjs\",\"language\":\"python3\"}]}}"]