a["{\"msg\":\"result\",\"id\":\"1610\",\"result\":{\"_id\":\"czGN5qceLFWba2j6F\",\"author\":\"Matt\",\"authorId\":\"BkPgkDQGHm66X4Qai\",\"code\":\"def is_self_describing(num):\\n\\t\",\"difficulty\":2.111111111111111,\"familyId\":\"BWiNGN63ALyGG5zSW\",\"instructions\":\"In this challenge, you have to establish if a given number is _self-describing_. To be _self-describing_, a positive number must have an even quantity of digits, because it has to be split into separated pairs of adjacent digits `x` and `y`, and each pair can be interpreted as a declaration: **among the digits of the number, there are `x` instances of the digit equal to `y`**.\\n\\nIf we take as an example the self-describing number `10123331`, we can see how it has an even quantity of digits and it can be split into four pairs:\\n\\n- `[1, 0]` ➞ This pair declares that among the digits of the number there is `1` instance of `0`\\n- `[1, 2]` ➞ This pair declares that among the digits of the number there is `1` instance of `2`\\n- `[3, 3]` ➞ This pair declares that among the digits of the number there are `3` instances of `3`\\n- `[3, 1]` ➞ This pair declares that among the digits of the number there are `3` instances of `1`\\n\\nIf every \\\"declaration\\\" represented by the pairs is true (as in the above example), then the number is self-describing.\\n\\nGiven a non-negative integer `num`, implement a function that returns `True` if `num` is a self-describing number, or `False` if it's not.\\n\\n### Examples\\n```\\nis_self_describing(10123331) ➞ True\\n# See the Instructions\\n\\nis_self_describing(224444) ➞ True\\n# Pair [2, 2] is True (two times 2 into num)\\n# Pair [4, 4] is True (four times 4 into num)\\n# Pair [4, 4] is True (same as previous)\\n\\nis_self_describing(2211) ➞ False\\n# Pair [2, 2] is True (two times 2 into num)\\n# Pair [1, 1] is False! It declares: one time 1 into num...\\n# ...but 2211 has two instances of 1 among its digits\\n\\nis_self_describing(333) ➞ False\\n# Odd quantity of digits, it can't be splitted\\n```\\n\\n### Notes\\n- Pairs can be repeated (see example #2), but they have to be true in any case.\\n- Remember to consider the totality of the digits of the number, when checking if a pair represents a true declaration (see example #3).\\n- You can expect always valid non-negative integers as input.\",\"isHidden\":false,\"lab\":\"Test.assert_equals(is_self_describing(10123331), True, \\\"Example #1\\\")\\nTest.assert_equals(is_self_describing(224444), True, \\\"Example #2\\\")\\nTest.assert_equals(is_self_describing(2211), False, \\\"Example #3\\\")\\nTest.assert_equals(is_self_describing(333), False, \\\"Example #4\\\")\\nTest.assert_equals(is_self_describing(1), False)\\nTest.assert_equals(is_self_describing(27273332), True)\\nTest.assert_equals(is_self_describing(11), False)\\nTest.assert_equals(is_self_describing(22), True)\\nTest.assert_equals(is_self_describing(19212332), True)\\nTest.assert_equals(is_self_describing(4444332231), False)\\nTest.assert_equals(is_self_describing(881722888888), True)\",\"language\":\"python3\",\"summary\":\"In this challenge, you have to establish if a given number is self-describing. To be self-describing, a positive number must have an even quantity of digits, because it has to be split into separated pairs of adjacent digits x and y, and each pair can be interpreted as a declaration: among the digits of the number, there are x instances of the digit equal to y\",\"tags\":[\"numbers\",\"arrays\",\"conditions\",\"loops\"],\"timestamp\":{\"$date\":1580350953724},\"title\":\"Digital Egomania: the Self-Describing Numbers\",\"stats\":{\"completed\":{\"total\":72,\"ratings\":[2,2,2,2,2,2,2,2,2,2,2,2,3,2,2,3,3,2,3,0,2,1,2,3,1,3,1,3,3,1,3,2,2,2,5,3,3,3,3,3,1,1,3,3,3,1,3,2,2,3,0,0,1,0,0,3,2,2,2,3,3,1,3],\"rators\":[\"tAF9Gf6PiGogbZuWs\",\"Jqk2uJZZxEv5wZFze\",\"gb9rvGus2Jv7bjZSs\",\"8JyqsSbN2FJXPr3cw\",\"2innwjWqxJHo4eRGh\",\"2fxapKr8XGdNeaKi2\",\"s5M5RvgqR9BhB9JoC\",\"iMHrN3Wiefh9Ame38\",\"C4QntmkYtB89GNtpd\",\"yZvzB3qFb8pkHy4dg\",\"AasGs8AeX9Lcb9xJn\",\"8PwfYqoDQFThzNtvf\",\"pmgFEciNrd3ES9tuu\",\"PytNZK9mNiRiZxPrm\",\"Z85ajWfZ4jDPkbvR4\",\"w3A7cBWyAfukk6xEQ\",\"wPxeazAYct9gG2eRM\",\"mDWNyaaQ9hvPCRzSd\",\"aCNWav8S8Try9RkC6\",\"pkQBaSzukotPEXmrD\",\"wZoxzQDbso9SMAPkY\",\"aEm3Wvj2rFYRL8Lrb\",\"muQCKmimwtNAdS8rp\",\"dXMbkgQFoN37BhruB\",\"ZNnsMeNkdDhHjSrZb\",\"55RQznnuTGpsj3EXd\",\"YRstQuthRkFeBiXug\",\"Yp7uvStL97cC9fKkY\",\"gJYuGdkXEWWmGRLzu\",\"J5T8gZqiZXFuFDTQ7\",\"9dgvEreRDYRiwLmYv\",\"jL4y5fTJAMBjhZmko\",\"a777e8chPvJkY3tKa\",\"iojEnnY9FsMfYzp6f\",\"KZ2xddpM2f9JRaryB\",\"d8qtzoLB264iP8tdY\",\"yjtdwc2AC4jA2RWtn\",\"iS5BrkGLzJyPK7nKt\",\"DEDniTrstQYGounXT\",\"9CoqdidjM9KbeKnHY\",\"ygDJ7HEzRoJZyPEF4\",\"xn7uGNKeAwPEkP9oA\",\"J3upzLHuEwXH7Z2hx\",\"DPi9QGLctq2y76KuE\",\"yTtSCvGPyYna6JuRC\",\"gXTAie79kiw28tx5u\",\"p8qqFdJ3FSk5x9z3G\",\"4Kd9kkoZYXraqycwR\",\"QRv96jmNaYsWkxQEG\",\"eHcgvkTGsH7ZziqBo\",\"hzHsgwjark5sZCQ2c\",\"oBcs8GLX2ZFLXQy8y\",\"cAP3n5NY64uoMwzRR\",\"AFfw7cGg83uYk2Miy\",\"HqmxnQJM66Y57twhn\",\"GGdmhAvxXhqhhibJN\",\"PWgzeK859suojbrRx\",\"T6iBEE2jp7f7iEF2P\",\"gKnWjDjwrJh7MK2df\",\"2PufnQcsHsfymufX3\",\"o4ixjQGSaYqA2JoM4\",\"yod5YhKtPqw2GfG9B\",\"rhS8qXRjZcpDXkwnE\",\"buX4mCQhtXCfBjeno\",\"suArq5BbSy7gD6xri\",\"8sNv5PTHa7XQ8bNqR\",\"Ds7L5bksw2QRHjrKL\"],\"quality\":[5,5,4,3,4,5,5,5,5]},\"instructions\":{\"upvoters\":[],\"downvoters\":[]},\"flags\":0},\"quality\":4.555555555555555,\"family\":[{\"_id\":\"N2W9jrLJW8Loca2h7\",\"language\":\"cpp\"},{\"_id\":\"8NfwhJ4eGriwj8AYS\",\"language\":\"javascript\"},{\"_id\":\"czGN5qceLFWba2j6F\",\"language\":\"python3\"},{\"_id\":\"3BNLKnYGQ5opgrrdN\",\"language\":\"ruby\"}]}}"]