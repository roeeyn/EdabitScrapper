a["{\"msg\":\"result\",\"id\":\"2467\",\"result\":{\"_id\":\"5k25ZqnuFgtgHNAqh\",\"author\":\"MyName\",\"authorId\":\"P7NmFbCJ5offXMRvB\",\"code\":\"def hamming_checker(block):\\n\\t\",\"difficulty\":4.6923076923076925,\"quality\":0,\"editorId\":\"P7NmFbCJ5offXMRvB\",\"familyId\":\"GX2BqgFnGd5zmKa2E\",\"instructions\":\"When a message, expressed as a long stream of `0`s and `1`s, is sent to you, one or more of its bits might get flipped on the way. If that's the case, it can be useful to have some way of figuring out if and where a \\\"bit flip\\\" happened so as to flip it back. One solution is to include in the message some form of meta-information about the message itself than can help you decide if the message has been corrupted or not.\\n\\n_Hamming code_ is a block of code that includes **redundant bits** in it. These bits are not to be considered part of the message itself but are used to tell if the **non-redundant bits** are fine, or if one has been flipped. As an illustration, consider a message with 16 bits:\\n\\n```\\n0111\\n0010\\n1110\\n0100\\n```\\n\\nIn this block, 4 bits are redundant and 11 carry the message (the bit in position `0` won't be used in this challenge). The redundant bits always have powers of two as their indices, so they occupy positions `1`, `2`, `4`, and `8` here. The way they encode information about the message is:\\n- Each redundant bit is in charge of checking a given region of the code.\\n- The `1`s inside each region are counted. If the number of `1`s is odd, the redundant bit for that region is a `1` so as to make the count even. If it is already even, the redundant bit is a `0`.\\n- Each region divides the block in the following manner:\\n\\n![hamming_code](https://edabit-challenges.s3.amazonaws.com/YQ6MUZV.png)\\n\\nThe red rectangles represent a region, and the redundant bit in charge of it is underlined for each of them. This block is probably uncorrupted since the number of `1`s is even for all regions.\\n\\nYour task is to write a function that takes a Hamming block and checks for corrupted bits. If the Hamming method finds no corrupted bits, return the same block as the input. If one corrupted bit is found, return the fixed code. For this challenge, there won't be more than one error per block.\\n\\nHint: Hamming blocks are designed so that the (number of `1`s) mod 2 of all regions \\\"spell out\\\" the reversed index of the corrupted bit in binary. For example:\\n\\n```\\n0110    region 1: 3 mod 2 = 1    corrupted bit: index 0011 (decimal 3)\\n0010    region 2: 3 mod 2 = 1\\n1110    region 3: 2 mod 2 = 0\\n0100    region 4: 4 mod 2 = 0\\n```\\n\\nIn general, think of all indices in binary and you might find some interesting patterns. \\n\\n### Examples\\n```\\nhamming_checker(\\\"0100100100010010\\\") ➞ \\\"0100100000010010\\\"\\n# The corrupted bit is in position 7.\\n\\nhamming_checker(\\\"0011011010100110\\\") ➞ \\\"0010011010100110\\\"\\n# The corrupted bit is in position 3.\\n\\nhamming_checker(\\\"0010101011111111\\\")  ➞ \\\"0010101011111111\\\"\\n# There are no corrupted bits.\\n```\\n\\n### Notes\\n- All blocks will be size 16.\\n- There will be at most one bit flip per block.\\n- For a visual explanation of this challenge and a possible solution, check out the videos in the Resource tab.\\n- For more, check out [part 2](https://edabit.com/challenge/k9GSNAEL5mS4yPtLv).\",\"isFree\":false,\"isHidden\":false,\"lab\":\"tests_corr = ['0100100100010010', '0011011010100110', '0010101011111111', '0101011000111110', '0101101101101111', \\n              '0011110101010111', '0010000001001100', '0110000111001000', '0010001011010010', '0100110010100110', \\n              '0010101111000101', '0000111010101101', '0101101010100100', '0100111100111101', '0110111111000000']\\n\\ntests_sol = ['0100100000010010', '0010011010100110', '0010101011111111', '0101011000111111', '0101001101101111', \\n         '0011110100010111', '0010000001101100', '0110000110001000', '0010001011010010', '0000110010100110', \\n         '0010001111000101', '0000111010111101', '0101101010100101', '0100111100111111', '0100111111000000']\\n\\ncorr_bit = ['7', '3', 'No corrupted bit', '15', '4', '9', '10', '9', 'No corrupted bit', '1', '4', '11', '15', '14', '2']\\n\\nfor i in range(15):\\n\\tTest.assert_equals(hamming_checker(tests_corr[i]), tests_sol[i], 'The corrupted bit is in position '+corr_bit[i])\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,3,5,5,3,5,5,5,5],\"quality\":[],\"rators\":[\"aEm3Wvj2rFYRL8Lrb\",\"P7NmFbCJ5offXMRvB\",\"QBgP4BySQAeCoCFf6\",\"yfT2efHZk3MyLr7Q5\",\"eHcgvkTGsH7ZziqBo\",\"iS5BrkGLzJyPK7nKt\",\"LQxof8pGabGuWP7Gn\",\"gJYuGdkXEWWmGRLzu\"],\"total\":10},\"flags\":0},\"summary\":\"When a message, expressed as a long stream of 0s and 1s, is sent to you, one or more of its bits might get flipped on the way. If that's the case, it can be useful to have some way of figuring out if and where a \\\"bit flip\\\" happened so as to flip it back. One solution is to include in the message some form of meta-information about the message itself than can h\",\"tags\":[\"bit_operations\",\"logic\",\"numbers\"],\"timestamp\":{\"$date\":1599839836478},\"title\":\"Error Detection Part 1: The Hamming Checker\",\"family\":[{\"_id\":\"5k25ZqnuFgtgHNAqh\",\"language\":\"python3\"}]}}"]