a["{\"msg\":\"result\",\"id\":\"2246\",\"result\":{\"_id\":\"yFqZ8YNTPumtuiNQr\",\"author\":\"Alessandro Manicone\",\"authorId\":\"AasGs8AeX9Lcb9xJn\",\"code\":\"def eadibitan(word):\\n\\t\",\"difficulty\":3.5,\"editorId\":\"AasGs8AeX9Lcb9xJn\",\"familyId\":\"Rt4hHdxPCSLndk8fK\",\"instructions\":\"You're creating a conlang called **Eadibitan**. But you're too lazy to come up with your own phonology, grammar and orthography. So you've decided to automatize the proccess.\\n\\nWrite a function that translates an English word into Eadibitan.\\n\\nEnglish syllables should be analysed according to the following rules:\\n- Syllables will follow the pattern (C)(C)V(V(V))(C), where C is a consonant and V is a vowel. Parentheses indicate that an element is optional.\\n- The pattern CVCV will be analyzed as CV-CV.\\n- The pattern CVCCV will be analyzed as CVC-CV\\n- The pattern CVCCCV will be analyzed as CVC-CCV\\n- Two or three consecutive vowels will always form a diphthong and a triphthong respectively. Meaning they will be grouped in the same syllable.\\n- A `y` should be analyzed as a consonant if followed by a vowel, and as a vowel otherwise.\\n\\nThe order of the letters of each syllable should be altered according to the following table:\\n\\nEnglish | Eadibitan\\n--- | ---\\nc1 v1 | v1 c1\\nc1 v1 v2 | v1 c1 v2\\nc1 v1 v2 v3 | v1 c1 v2 v3\\nc1 v1 c2 | v1 c1 c2\\nc1 v1 v2 c2 | v1 c1 v2 c2\\nc1 v1 v2 v3 c2 | v1 c1 v2 v3 c2\\nc1 c2 v1 | c2 v1 c1\\nc1 c2 v1 v2 | c2 v1 c1 v2\\nc1 c2 v1 v2 v3 | c2 v1 c1 v2 v3\\nc1 c2 v1 c3 | c2 v1 c1 c3\\nc1 c2 v1 v2 c3 | c2 v1 c1 v2 c3\\nc1 c2 v1 v2 v3 c3 | c2 v1 c1 v2 v3 c3\\n\\nAny other pattern should be left untouched.\\n\\n### Examples\\n```\\neadibitan(\\\"edabitian\\\") ➞ \\\"eadibitan\\\"\\n\\neadibitan(\\\"star\\\") ➞ \\\"tasr\\\"\\n\\neadibitan(\\\"beautiful\\\") ➞ \\\"ebauitufl\\\"\\n\\neadibitan(\\\"statistically\\\") ➞ \\\"tasitsitaclyl\\\"\\n```\\n\\n### Notes\\n- You can expect only lower case single words as arguments.\\n- **~~Obvious~~ Bonus**: Try to solve it using RegEx.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"Test.assert_equals(eadibitan(\\\"edabitian\\\"), \\\"eadibitan\\\")\\nTest.assert_equals(eadibitan(\\\"star\\\"), \\\"tasr\\\")\\nTest.assert_equals(eadibitan(\\\"beautiful\\\"), \\\"ebauitufl\\\")\\nTest.assert_equals(eadibitan(\\\"statistically\\\"), \\\"tasitsitaclyl\\\")\\nTest.assert_equals(eadibitan(\\\"function\\\"), \\\"ufnticon\\\")\\nTest.assert_equals(eadibitan(\\\"variable\\\"), \\\"avirabel\\\")\\nTest.assert_equals(eadibitan(\\\"thisisnotreallyawordbutistranslatable\\\"), \\\"hitissonteralyalowrbuditsratnlasatbel\\\")\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[2,2,2,2,2,3,5,5,3,4,5,4,5,5,5,2,2,2,5,5],\"rators\":[\"AasGs8AeX9Lcb9xJn\",\"s5M5RvgqR9BhB9JoC\",\"8PwfYqoDQFThzNtvf\",\"aEm3Wvj2rFYRL8Lrb\",\"SKeSSfqSmCk65vjYh\",\"SGhPxX5bHGL8zZqtt\",\"FgkYtHLxeD8pETJ8T\",\"n9DbcPwhotC5XbfN3\",\"mDWNyaaQ9hvPCRzSd\",\"h4x2jaMdj5aQZbW5g\",\"ntaGcjhFbafszWWZ7\",\"yjtdwc2AC4jA2RWtn\",\"J23RcmzbdtBbPCTjT\",\"iS5BrkGLzJyPK7nKt\",\"gJYuGdkXEWWmGRLzu\"],\"total\":15,\"quality\":[]},\"flags\":0},\"summary\":\"You're creating a conlang called Eadibitan. But you're too lazy to come up with your own phonology, grammar and orthography. So you've decided to automatize the proccess.\\n\\nWrite a function that translates an English word into Eadibitan.\\n\\nEnglish syllables should be analysed according to the following rules:\\nSyllables will follow the pattern (C)(C)V(V(V))(C), w\",\"tags\":[\"strings\",\"formatting\",\"cryptography\"],\"timestamp\":{\"$date\":1590409646964},\"title\":\"Lazy Conlanging\",\"quality\":0,\"family\":[{\"_id\":\"7trtKePdP39FN3iKo\",\"language\":\"cpp\"},{\"_id\":\"qdpd4bj9832ZzcS7x\",\"language\":\"javascript\"},{\"_id\":\"yFqZ8YNTPumtuiNQr\",\"language\":\"python3\"},{\"_id\":\"8E9qpE52gB7LpbTYT\",\"language\":\"ruby\"}]}}"]