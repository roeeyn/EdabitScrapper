a["{\"msg\":\"result\",\"id\":\"2143\",\"result\":{\"_id\":\"cvA35yPFAggr7rtve\",\"author\":\"Luis Pereira\",\"authorId\":\"aEm3Wvj2rFYRL8Lrb\",\"code\":\"def last_ancestor(folders, X, Y):\\n\\t\",\"difficulty\":3.240740740740741,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"PrYkX3uuzvRgdWEEi\",\"instructions\":\"This is a sequel to [part #1](https://edabit.com/challenge/9yk63KrKDHzNFWKBJ), with the same setup, but a different goal.\\n\\nA folder system on a computer might look something like the picture below:\\n\\n![](https://edabit-challenges.s3.amazonaws.com/folders_smaller.png)\\n\\nIn this challenge, folder systems will be represented by dictionaries where the keys are folders `X` and the value at `X` is the list of subfolders of `X`.\\n\\nFor example, the picture above becomes the dictionary:\\n\\n```\\n{\\n  \\\"A\\\": [\\\"B\\\", \\\"C\\\", \\\"D\\\"],\\n  \\\"B\\\": [\\\"E\\\", \\\"F\\\"],\\n  \\\"D\\\": [\\\"G\\\", \\\"H\\\"],\\n  \\\"G\\\": [\\\"I\\\", \\\"J\\\"],\\n  \\\"H\\\": [\\\"K\\\"]\\n}\\n```\\n\\nThe inputs for this challenge will be:\\n- A dictionary representing a folder system.\\n- Two folders `X` and `Y`.\\n\\nWrite a function that finds the \\\"smallest\\\" folder containing both `X` and `Y` (in the illustration, this is the lowest folder for which you can travel down to both `X` and `Y`; or, if you view the system as a \\\"family tree\\\", this is the last common ancestor).\\n\\n\\n### Examples\\n```\\nlast_ancestor({\\n  \\\"A\\\": [\\\"B\\\", \\\"C\\\", \\\"D\\\"],\\n  \\\"B\\\": [\\\"E\\\", \\\"F\\\"],\\n  \\\"D\\\": [\\\"G\\\", \\\"H\\\"],\\n  \\\"G\\\": [\\\"I\\\", \\\"J\\\"],\\n  \\\"H\\\": [\\\"K\\\"]\\n}, \\\"B\\\", \\\"C\\\") ➞ \\\"A\\\"\\n\\nlast_ancestor({\\n  \\\"A\\\": [\\\"B\\\", \\\"C\\\", \\\"D\\\"],\\n  \\\"B\\\": [\\\"E\\\", \\\"F\\\"],\\n  \\\"D\\\": [\\\"G\\\", \\\"H\\\"],\\n  \\\"G\\\": [\\\"I\\\", \\\"J\\\"],\\n  \\\"H\\\": [\\\"K\\\"]\\n}, \\\"I\\\", \\\"J\\\") ➞ \\\"G\\\"\\n\\nlast_ancestor({\\n  \\\"A\\\": [\\\"B\\\", \\\"C\\\", \\\"D\\\"],\\n  \\\"B\\\": [\\\"E\\\", \\\"F\\\"],\\n  \\\"D\\\": [\\\"G\\\", \\\"H\\\"],\\n  \\\"G\\\": [\\\"I\\\", \\\"J\\\"],\\n  \\\"H\\\": [\\\"K\\\"]\\n}, \\\"I\\\", \\\"K\\\") ➞ \\\"D\\\"\\n\\nlast_ancestor({\\n  \\\"A\\\": [\\\"B\\\", \\\"C\\\", \\\"D\\\"],\\n  \\\"B\\\": [\\\"E\\\", \\\"F\\\"],\\n  \\\"D\\\": [\\\"G\\\", \\\"H\\\"],\\n  \\\"G\\\": [\\\"I\\\", \\\"J\\\"],\\n  \\\"H\\\": [\\\"K\\\"]\\n}, \\\"D\\\", \\\"I\\\") ➞ \\\"D\\\"\\n\\nlast_ancestor({\\n  \\\"A\\\": [\\\"B\\\", \\\"C\\\", \\\"D\\\"],\\n  \\\"B\\\": [\\\"E\\\", \\\"F\\\"],\\n  \\\"D\\\": [\\\"G\\\", \\\"H\\\"],\\n  \\\"G\\\": [\\\"I\\\", \\\"J\\\"],\\n  \\\"H\\\": [\\\"K\\\"]\\n}, \\\"G\\\", \\\"G\\\") ➞ \\\"G\\\"\\n```\\n\\n### Notes\\n- All the examples above use the folder system in the illustration, but the tests will use other folder systems as well.\\n- For the purposes of this challenge, any folder is inside itself, as in the last two examples.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"Test.assert_equals(last_ancestor({'A':['B', 'C', 'D'], 'B':['E', 'F'], 'D':['G', 'H'], 'G':['I', 'J'], 'H': ['K']}, 'B', 'C'), 'A')\\nTest.assert_equals(last_ancestor({'A':['B', 'C', 'D'], 'B':['E', 'F'], 'D':['G', 'H'], 'G':['I', 'J'], 'H': ['K']}, 'I', 'J'), 'G')\\nTest.assert_equals(last_ancestor({'A':['B', 'C', 'D'], 'B':['E', 'F'], 'D':['G', 'H'], 'G':['I', 'J'], 'H': ['K']}, 'I', 'K'), 'D')\\nTest.assert_equals(last_ancestor({'A':['B', 'C', 'D'], 'B':['E', 'F'], 'D':['G', 'H'], 'G':['I', 'J'], 'H': ['K']}, 'I', 'D'), 'D')\\nTest.assert_equals(last_ancestor({'A':['B', 'C', 'D'], 'B':['E', 'F'], 'D':['G', 'H'], 'G':['I', 'J'], 'H': ['K']}, 'G', 'G'), 'G')\\nTest.assert_equals(last_ancestor({'A':['B', 'C', 'D'], 'B':['E', 'F'], 'D':['G', 'H'], 'G':['I', 'J'], 'H': ['K']}, 'F', 'G'), 'A')\\nTest.assert_equals(last_ancestor({'A':['B', 'C', 'D'], 'B':['E', 'F'], 'D':['G', 'H'], 'G':['I', 'J'], 'H': ['K']}, 'F', 'E'), 'B')\\n\\n# Different folder system\\nTest.assert_equals(last_ancestor({'A':['B', 'E'], 'B':['R', 'F'], 'D':['S', 'H'], 'G':['A', 'D'], 'S': ['K']}, 'E', 'R'), 'A')\\nTest.assert_equals(last_ancestor({'A':['B', 'E'], 'B':['R', 'F'], 'D':['S', 'H'], 'G':['A', 'D'], 'S': ['K']}, 'K', 'H'), 'D')\\nTest.assert_equals(last_ancestor({'A':['B', 'E'], 'B':['R', 'F'], 'D':['S', 'H'], 'G':['A', 'D'], 'S': ['K']}, 'D', 'S'), 'D')\\nTest.assert_equals(last_ancestor({'A':['B', 'E'], 'B':['R', 'F'], 'D':['S', 'H'], 'G':['A', 'D'], 'S': ['K']}, 'E', 'K'), 'G')\\nTest.assert_equals(last_ancestor({'A':['B', 'E'], 'B':['R', 'F'], 'D':['S', 'H'], 'G':['A', 'D'], 'S': ['K']}, 'F', 'R'), 'B')\\nTest.assert_equals(last_ancestor({'A':['B', 'E'], 'B':['R', 'F'], 'D':['S', 'H'], 'G':['A', 'D'], 'S': ['K']}, 'F', 'G'), 'G')\\nTest.assert_equals(last_ancestor({'A':['B', 'E'], 'B':['R', 'F'], 'D':['S', 'H'], 'G':['A', 'D'], 'S': ['K']}, 'A', 'K'), 'G')\",\"language\":\"python3\",\"stats\":{\"completed\":{\"ratings\":[2,2,2,2,2,2,3,3,4,2,3,5,4,3,4,4,3,4,2,3,4,5,5,3,5,5,0,3,4,0,5,5,3,2,2,4,3,4,5,3,5,5,3,3,5,5,1,2,3,3,3,3,1,4],\"rators\":[\"aEm3Wvj2rFYRL8Lrb\",\"AasGs8AeX9Lcb9xJn\",\"8PwfYqoDQFThzNtvf\",\"mDWNyaaQ9hvPCRzSd\",\"8JyqsSbN2FJXPr3cw\",\"poqx2psfWnEswCdYB\",\"DwetpbChQM4r6Gwah\",\"uTKCSekw6me9swLdk\",\"ywk3XGvcmpTgRxwZa\",\"YRstQuthRkFeBiXug\",\"Phd2FdPjo9BhBfvKh\",\"jL4y5fTJAMBjhZmko\",\"wT5gGgvjKc5wz59AQ\",\"SpTi3f5uA7t7ygtLv\",\"ZNnsMeNkdDhHjSrZb\",\"eHhL37DG7oW3vTcg7\",\"bLpgu8xTdpDPFSAsM\",\"5H9MNfC4DPwxbakTf\",\"NaPpyhnXZ2XLtug83\",\"Xt5mpxGr5P5GLiAJH\",\"KpHrC7WPEojnzgEtz\",\"hZW6j5s6RHpx35phy\",\"J83b6T9hJ2EqE5Aov\",\"W5TajitmCyxz87zAC\",\"ENS9wE2HHz2Y5DjRk\",\"62agN2oNiy8R7CxLy\",\"SGhPxX5bHGL8zZqtt\",\"xn7uGNKeAwPEkP9oA\",\"jFcHRfu77aNu6YpZg\",\"YLtspA8ec6ntcoMMf\",\"Nfsj4eNFDjaFa39ga\",\"diA4hKkZ9WRCu4ive\",\"fznzd3qnvtbFkkizz\",\"GgLd4eWBu79mdjtkP\",\"4fhjJBvLBWh6QeSih\",\"gnqiMtWWsK2aCjbpA\",\"oZiGwL535nJ5ZMJr7\",\"5dHucvf2qBYyKim7X\",\"h4x2jaMdj5aQZbW5g\",\"DNACg4rcgZsPtYGZ8\",\"ReJkqc43MY6pNcMDh\",\"syYx2CZhdo5kPZiSW\",\"Cia25zjeX3RkCNx5t\",\"QBgP4BySQAeCoCFf6\",\"d6iEb2BDDofyeePh9\",\"iS5BrkGLzJyPK7nKt\",\"mH5AfrrfASMdRvhtK\",\"8sNv5PTHa7XQ8bNqR\",\"2PufnQcsHsfymufX3\",\"iojEnnY9FsMfYzp6f\",\"yjtdwc2AC4jA2RWtn\",\"bJaPCBx63YxdJAuTS\",\"gJYuGdkXEWWmGRLzu\",\"vkNC5wKndyFK8rQDK\",\"C8A4KqXAQ4zmfBmmf\",\"P3xfj7DTJPStBxfq9\",\"J23RcmzbdtBbPCTjT\",\"wNLWme2gvvpMPHk7A\",\"e6Ldo3gXosENLvaRq\"],\"total\":66,\"quality\":[3,5,5,4,5,5,5,5,5,5]},\"flags\":1},\"summary\":\"This is a sequel to part #1, with the same setup, but a different goal.\\n\\nA folder system on a computer might look something like the picture below:\\n\\nIn this challenge, folder systems will be represented by dictionaries where the keys are folders X and the value at X is the list of subfolders of X.\\n\\nFor example, the picture above becomes the dictionary:\\n\\n{\\n\\t\\\"A\\\"\",\"tags\":[\"algorithms\",\"data_structures\",\"logic\"],\"timestamp\":{\"$date\":1586914339108},\"title\":\"Folder Challenge (Part #2)\",\"quality\":4.7,\"family\":[{\"_id\":\"cvA35yPFAggr7rtve\",\"language\":\"python3\"}]}}"]