a["{\"msg\":\"result\",\"id\":\"822\",\"result\":{\"_id\":\"EDZj2oGeLTKgDSJzc\",\"author\":\"_fluffyy\",\"authorId\":\"foytX6kH9wiSYqLtT\",\"code\":\"public class MiddleSquarePRNG {\\n  public void seed(int newSeed) {\\n\\t\\t\\n  }\\n\\n  public int next() {\\n\\t\\t\\n  }\\n}\",\"difficulty\":3.7142857142857144,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"jnfhzK799aEfL3WwF\",\"instructions\":\"Create a class that returns 32-bit pseudo-random numbers using the middle square algorithm.\\n\\n### Background\\nComputers were built to be *deterministic*, which means every action it performs is 100% predictable. However, in the case of random number generation (RNG), this makes it hard to come up with \\\"random\\\" numbers. To circumvent this, many people have come up with *pseudo-random* number generators (PRNG) which generate numbers that *seem* random, but are still perfectly predictable if you know how the algorithm works. One of these algorithms is called the **middle square** algorithm.\\n\\nPRNGs typically take in a \\\"seed\\\" as their initial state. Then, to generate a new random number, you perform some series of calculations on that state and then set the state to that new number. The middle square algorithm is no different -- it takes a seed and then performs a series of calculations to find the next number.\\n\\nLet's say you want to generate two-digit random numbers. To generate a new number, start with your state:\\n\\n```\\n85\\n```\\nSquare it:\\n\\n```\\n85^2=7225\\n```\\nand take the two middle digits:\\n\\n```\\n22\\n```\\n\\n... to get the next random number.\\n\\nOnce you've retrieved the next number, *store it into the state to be used later* and then return it. You can repeat this as many times as you want to generate as many \\\"random\\\" numbers as needed:\\n\\n```\\n22\\n22^2=0484 (pad the number with zeroes)\\n48 <- next random number\\n48^2=2304\\n30 <- next random number\\n30^2=0900\\n90 <- next random number\\n90^2=8100\\n10 <- next random number\\n10^2=0100\\n10 <- next random number\\n```\\n\\nThis particular number is important since we've generated the number `10` twice now. Because of how the algorithm works, this means that the generator will start infinitely generating tens.\\n\\n### Instructions\\nFor this challenge, instead of generating two-digit decimal numbers, we'll be generating *32-bit binary numbers.* Example:\\n\\n```\\n00101000010100001010110110000010 (equal to 676,375,938)\\n0000011001011001010011111010010110000110110110001111011000000100 (equal to 457,484,409,505,379,844)\\n01001111101001011000011011011000 (digits 16-48; equal to 1,336,248,024) <- next random number\\n```\\n\\n**Your task is to create a `MiddleSquarePRNG` class with the following methods:**\\n- `void seed(int newSeed)` -- set the state to `newSeed`\\n- `int next()` -- return the next pseudo-random number\\n\\n### Examples\\n```\\nMiddleSquarePRND rand = new MiddleSquarePRND();\\nrand.seed(6492);\\nassert rand.next() == 643;\\nassert rand.next() == 6;\\nassert rand.next() == 0;\\nassert rand.next() == 0;\\n```\\n\\n### Notes\\n- You might want to store the state as a `long` instead of an `int` to square it.\\n- Remember that the `next()` method returns an `int` and not a `long`!\\n- Bit operations could help here.\\n- Don't worry about signs \u2060â€” none of the numbers will get big enough to use them.\\n- I've tried to organize the tests to make them easier to read at first glance.\\n- **This is not a good method of generating pseudo-random numbers!**\",\"isFree\":false,\"isHidden\":false,\"lab\":\"import org.junit.Test;\\nimport static org.junit.Assert.assertEquals;\\npublic class MiddleSquareTests {\\n  private static MiddleSquarePRNG rand = new MiddleSquarePRNG(); @Test public void test01()\\n  { rand.seed(6492);  assertEquals(643,      rand.next()); }     @Test public void test02()\\n  {                  assertEquals(6,        rand.next()); }     @Test public void test03()\\n  {                  assertEquals(0,        rand.next()); }     @Test public void test04()\\n  {                  assertEquals(0,        rand.next()); }     @Test public void test05()\\n  { rand.seed(95724); assertEquals(139817,   rand.next()); }     @Test public void test06()\\n  {                  assertEquals(298290,   rand.next()); }     @Test public void test07()\\n  {                  assertEquals(1357680,  rand.next()); }     @Test public void test08()\\n  {                  assertEquals(28126449, rand.next()); }     @Test public void test09()\\n  { rand.seed(66942); assertEquals(68378,    rand.next()); }     @Test public void test10()\\n  {                  assertEquals(71343,    rand.next()); }     @Test public void test11()\\n  {                  assertEquals(77664,    rand.next()); }     @Test public void test12()\\n  {                  assertEquals(92036,    rand.next()); }     @Test public void test13()\\n  {                  assertEquals(129251,   rand.next()); }     @Test public void test14()\\n  {                  assertEquals(254910,   rand.next()); }     @Test public void test15()\\n  {                  assertEquals(991502,   rand.next()); }     @Test public void test16()\\n  {                  assertEquals(15000552, rand.next()); }\\n}\",\"language\":\"java\",\"quality\":0,\"stats\":{\"completed\":{\"ratings\":[4,4,4,4,4,4,2],\"quality\":[],\"rators\":[\"gXTAie79kiw28tx5u\",\"c7uBxu2rgY77H5d79\"],\"total\":5},\"flags\":0},\"summary\":\"Create a class that returns 32-bit pseudo-random numbers using the middle square algorithm.\\n\\nBackground\\nComputers were built to be deterministic, which means every action it performs is 100% predictable. However, in the case of random number generation (RNG), this makes it hard to come up with \\\"random\\\" numbers. To circumvent this, many people have come up with\",\"tags\":[\"algorithms\",\"bit_operations\",\"numbers\"],\"timestamp\":{\"$date\":1610737962060},\"title\":\"Middle Square Algorithm (PRNG)\",\"family\":[{\"_id\":\"EDZj2oGeLTKgDSJzc\",\"language\":\"java\"}]}}"]