a["{\"msg\":\"result\",\"id\":\"159\",\"result\":{\"_id\":\"s8q6rQPs37zjkdya2\",\"author\":\"Nathan Hohnbaum\",\"authorId\":\"Li55JB322ZcMFGna8\",\"code\":\"public class Challenge {\\n  public static boolean adjacent(int[][] graph, int node1, int node2) {\\n\\t\\t\\n\\t}\\n}\",\"difficulty\":0.675,\"quality\":4.5,\"editorId\":\"Li55JB322ZcMFGna8\",\"familyId\":\"A68Y3j7bAd3dy458S\",\"instructions\":\"A directed graph is like an undirected graph except that edges have direction.  Each edge goes from a source node to a target node.\\n\\n### Examples\\n![Graph 1](https://edabit-challenges.s3.amazonaws.com/1_qFfswEI.png)\\n\\nHere, node 0 is adjacent to node 1, but node 1 is not adjacent to node 0, for example. Here is what the graph above would look like if it were undirected:\\n\\n![Graph 2](https://edabit-challenges.s3.amazonaws.com/2_VzUVh2D.png)\\n\\nIn directed graphs, the edge direction matters.  For example, the following two graphs are different:\\n\\n![Graph 3A](https://edabit-challenges.s3.amazonaws.com/3_95KqfbY.png)\\n\\n![Graph 3B](https://edabit-challenges.s3.amazonaws.com/4_GQqdOBR.png)\\n\\nWith undirected graphs, the adjacency matrix is symmetric about the main diagonal, but in a directed graph, it is not always the case.  In particular, a 1 in row _i_ and column _j_ indicates that there is an edge from _i_ to _j_.\\n\\n![Graph 1](https://edabit-challenges.s3.amazonaws.com/5_qFfswEI.png)\\n\\nThe following graph would have the following adjacency matrix:\\n\\n```\\n{\\n  {0, 1, 1, 0, 0},\\n  {0, 0, 0, 0, 0},\\n  {0, 1, 0, 0, 0},\\n  {0, 0, 1, 0, 1},\\n  {1, 0, 0, 0, 0}\\n}\\n```\\nWe can see that node 1 has no edges coming out of it.  That is reflected by its row being all zeros.  A node with no edges going into it would have a column of all zeros.\\n\\n#### Instructions\\nYour task is to, given the adjacency matrix of a directed graph and two nodes, determine whether or not the first node is adjacent to the second node.\\n\\n#### Notes\\n- Graphs may have between 0 and 25000 nodes.\\n- Time limit: 100 milliseconds.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"import org.junit.*;\\nimport static org.junit.Assert.*;\\n\\npublic class AdjacencyTest {\\n\\t\\n\\tprivate static int[][] graph1;\\n\\tprivate static int[][] singleNode;\\n\\tprivate static int[][] completeGraph;\\n\\tprivate static int[][] noEdgeGraph;\\n\\tprivate static int[][] largeGraph;\\n\\t\\n\\t@BeforeClass\\n\\tpublic static void setup() {\\n\\t\\tgraph1 = new int[][] {\\n\\t\\t\\t{0,1,1,0,1},\\n  \\t\\t{0,0,0,0,0},\\n  \\t\\t{0,1,0,0,0},\\n  \\t\\t{0,0,1,0,1},\\n  \\t\\t{1,0,0,0,0}\\n\\t\\t};\\n\\t\\tsingleNode = new int[1][1];\\n\\t\\tcompleteGraph = new int[5][5];\\n\\t\\tfor (int i=0; i<5; i++) {\\n\\t\\t\\tfor (int j=i+1; j<5; j++) {\\n\\t\\t\\t\\tif (i != j) {\\n\\t\\t\\t\\tcompleteGraph[i][j]=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tnoEdgeGraph = new int[5][5];\\n\\t\\tlargeGraph = new int[25000][25000];\\n\\t\\tlargeGraph[20000][5000] = 1;\\n\\t\\t\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test1() {\\n\\t\\tassertTrue(Challenge.adjacent(graph1,0,1));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test2() {\\n\\t\\tassertFalse(Challenge.adjacent(graph1,1,0));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test3() {\\n\\t\\tassertFalse(Challenge.adjacent(graph1,0,3));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test4() {\\n\\t\\tassertTrue(Challenge.adjacent(graph1,4,0));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test5() {\\n\\t\\tassertFalse(Challenge.adjacent(graph1,3,3));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test6() {\\n\\t\\tassertFalse(Challenge.adjacent(singleNode,0,0));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test7() {\\n\\t\\tassertTrue(Challenge.adjacent(completeGraph,0,4));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test8() {\\n\\t\\tassertFalse(Challenge.adjacent(completeGraph,4,2));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test9() {\\n\\t\\tassertFalse(Challenge.adjacent(noEdgeGraph,4,0));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test10() {\\n\\t\\tassertFalse(Challenge.adjacent(largeGraph,5000,20000));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test11() {\\n\\t\\tassertTrue(Challenge.adjacent(largeGraph,20000,5000));\\n\\t}\\n}\",\"language\":\"java\",\"stats\":{\"completed\":{\"ratings\":[0,0,0,0,0,0,0,0,0,0,0,1,3,1,0,0,0,0,1,1,0,0,0,0,1,1,1,2,1,1,0,2,0,1,2,0,1,0,0,0,0,1,0,1,0,2,0,0,0,0,1,0,0,1,1,2,1,1,0,2,2,2,1,2,2,2,0,0,0,2,1,0,0,3,1,0,0,1,1,1],\"quality\":[5,4,4,4,3,1,4,4,5,5,5,4,5,5,5,5,5,2,4,4,5,4,4,5,5,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5],\"rators\":[\"Li55JB322ZcMFGna8\",\"qaPjAANdnxFnWfj5d\",\"TSXhnSRKbxeTQiicx\",\"DEDniTrstQYGounXT\",\"AeJSxRqw2dJZuGvdk\",\"srsye5MYsuZwgsgBD\",\"Fnj8FeZChejwno74c\",\"RWEG66jLaG4jBXqCJ\",\"p2fmZdcTvnC7657Et\",\"yXGiiSAR5nBHnH3yr\",\"7fjsAnXYp3ckDAKfT\",\"kTZHvzFwJEiRGK5iH\",\"n5wubRfh6zh8QRymN\",\"MGotcrxMowBDdpCAC\",\"CBRiWyfmtC9xzCTf4\",\"EfrK7Prsam9RWKYKf\",\"a5Tuwi5SNDhW4N57Y\",\"TrquEHytntLKHA4m2\",\"NioGGZL9KCn5Ln96t\",\"eSYGda5XebPyQeG2a\",\"eaFkKqk7bnwLomrHv\",\"zKdb3cDytehHruckw\",\"oXEoxZ89ZwzwyBX8c\",\"4sA7sbNviGRdkApYa\",\"3zhLba4zdi3zCyLzr\",\"JosxsR4gX59Q55GeS\",\"HJDaZL9SEdpyFbi3i\",\"NvjQDrN5oK7yiKitJ\",\"5y7Mfm8LvideCvwpf\",\"SPwFrpFPYcED7xTfj\",\"79Wo8iNbhEr7BvrNE\",\"ktP6pH8aoeusvbvC6\",\"4YsFLuK9mno9RZiRr\",\"QjS3SRXLfnbj9auo2\",\"MBEwq8srjd2oA5W58\",\"M9fYmJcbxAvDWAaE9\",\"eE9G6Smr87PASdRZo\",\"DqTt5mzzQmeopdE4Z\",\"xv5obFhsxY93mqR5S\",\"jyoLggHk8xQKZuoQC\",\"vBgCh6uvCZXscLEoZ\",\"cueHAmTrcWuowXf58\",\"a49eNnfRwSMxsDJXf\",\"J7epB3qSQJ2E8vWkY\",\"Es4eX2stRpyoXeC7f\",\"t8tYLq5se8GxEd69K\",\"RJRwPFmGEsPuLYM5u\",\"hhxjQREtmHSheH9Pj\",\"PPHFum3dvD8pzLnGz\",\"44arJN5SYx3HyfetA\",\"7gBLtxKryhTryH5zb\",\"7W8yYT7ktkAoNo3u8\",\"2wS9Wm3Nj5ZFcMnfA\",\"yMcCkXC4GCyjvTbBC\",\"jqkZtB4n2ZgLbt5t5\",\"8xGeCLKDvRQhyxKNf\",\"xiKKZ4u3ksBaNwmjH\",\"gBGjCfJvPHswDM5JQ\",\"47PyFbZyxWuP9Bgga\",\"Fd9765rksgPK4E2Zy\",\"paM4HgbAJRfbxNG73\",\"yyeQ8kyxFphnx4A3h\",\"9toJmYWtyPgmyGood\",\"etoSR23iELGGgs9rA\",\"agReopRiQqrFmPMrS\",\"kFv5wWXR7P2tAwKuq\",\"8Xx8nWXRydHDBGfQf\",\"A7jCWrFZzCATJ3Qgm\",\"Yp7uvStL97cC9fKkY\",\"WA9ByhLbKKJTiZYf5\",\"CNc6rmwhbxkxEhHAp\",\"JwBT2xYDafcNG9eKr\",\"BDMzcwipsJSLoaRKx\",\"ikxSkiQjCjYPsFwMT\",\"umcNKSZ597NfCXiyy\",\"p7S65SrYRpA5bcJ5Y\",\"Zh7bMA9TAe5TTPKGr\",\"jtwXnqgBtW84HqNpB\",\"RAEFpazbe6mhx3PLb\",\"8DfhSneJpsw5uqLeM\",\"8n4ajMrpA6Mhb66Y9\",\"m8RTLuXqmythXHYZt\",\"kaSirKnRwXvGfe6ru\",\"2bemiz7sjLjCbA5ui\",\"8Y2Z8THNpSQpozXQ2\",\"wrYbGuhfFbNjwEtim\",\"84PnX6PD8izkkTcxT\",\"sacPXRKX59BE495oz\",\"XZCWhj8dfcs5wnkMx\",\"XQS4jE76BQZxd8xqB\",\"5jDgvkGd4JwatrYXg\",\"W56bWmpQeLJ9JEDsa\",\"Yj7ftjzyP67R5NFrH\",\"btabi3PdyisuY5tn9\",\"3SgSNoAB3sxaYeT3w\",\"QRv96jmNaYsWkxQEG\",\"EcBw39vkywQsT3Y2Z\",\"mDWNyaaQ9hvPCRzSd\",\"fCTfZSgeDbRbTvDY4\",\"oMZovHkR6QqNvQwyc\",\"t55QWHi8o4teZxqqE\",\"LNCb5rksJLJ43L4Nw\",\"xEX3TDY6C2h82dJTn\",\"sxci7DYKNa6q22Sjq\",\"uw47663LqPME8btaA\",\"rhS8qXRjZcpDXkwnE\",\"nSLvkGEpiYCtcBLaa\",\"cR3ibTMxLyEdDFCHY\",\"htXCitorobtqYymjN\",\"KMR6vNzvSKMA2cXnK\",\"RsujLHaML6L3KinzK\",\"ckQwFFWyLXmDQAaCn\",\"unqzSsxpxj9sZ7rbD\",\"F8dA24AosSC8XXb7D\",\"emk493xRkq5kPATnJ\"],\"total\":115},\"flags\":0},\"summary\":\"A directed graph is like an undirected graph except that edges have direction.  Each edge goes from a source node to a target node.\\n\\nExamples\\nGraph 1\\n\\nHere, node 0 is adjacent to node 1, but node 1 is not adjacent to node 0, for example. Here is what the graph above would look like if it were undirected:\\n\\nGraph 2\\n\\nIn directed graphs, the edge direction matters\",\"tags\":[\"algorithms\",\"math\",\"arrays\"],\"timestamp\":{\"$date\":1599930169224},\"title\":\"Adjacent Nodes (Directed Graph)\",\"family\":[{\"_id\":\"s8q6rQPs37zjkdya2\",\"language\":\"java\"}]}}"]