a["{\"msg\":\"result\",\"id\":\"850\",\"result\":{\"_id\":\"fSohszsuqKXYDDjGb\",\"author\":\"Nathan Hohnbaum\",\"authorId\":\"Li55JB322ZcMFGna8\",\"code\":\"public class Challenge {\\n  public static int moves(String start) {\\n\\t\\t\\n  }\\n}\",\"difficulty\":4.7272727272727275,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"4Yi8qcQHYuFCkQtH2\",\"instructions\":\"Given a string, a move is made by either removing the substring \\\"actor\\\" or by removing the substring \\\"intact\\\".  Upon removing a substring, a new string is produced, and moves may be made from the new string until no more moves are possible.\\n\\nFor example, given the string `\\\"inactortact\\\"`, one can first remove the substring `\\\"actor\\\"` to get `\\\"intact\\\"` and then remove the substring `\\\"intact\\\"` to get the empty string from which point, no more moves are possible.\\n\\nThe goal of this challenge is to determine the maximum number of moves that can be made from a starting string. Note that in some situations, more than one move is possible, and not all moves allow for as long of sequences of moves. \\n\\nFor example, consider the string `\\\"actintactor\\\"`. One could remove the substring `\\\"intact\\\"` to get `\\\"actor\\\"` and then remove `\\\"actor\\\"` to get to the empty string (2 moves), but removing `\\\"actor\\\"` from the end produces the substring `\\\"actint\\\"`, from which no more moves are possible.\\n\\n### Examples\\n- \\\"intactor\\\":  int~~actor~~\\\" ➞ \\\"int\\\" (1 move)\\n- \\\"actorbintact\\\": \\\"~~actor~~bintact\\\" ➞ \\\"b~~intact~~\\\" ➞ \\\"b\\\" (2 moves)\\n- \\\"intor\\\": \\\"intor\\\" has no moves that can be made\\n- \\\"intintactactororact\\\": \\\"intintact~~actor~~oract\\\" ➞ \\\"intint~~actor~~act\\\" ➞ \\\"int~~intact~~\\\" ➞ \\\"int\\\" (3 moves)\\n\\n### Notes\\n- All strings are composed of lowercase letters.\\n- Strings are between 0 and 1000 characters in length.\\n- Time limit: 100 milliseconds.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"import org.junit.*;\\nimport static org.junit.Assert.*;\\n\\npublic class MovesTest {\\n\\t\\n\\t// A long string with a linear sequence of moves that can be made\\n\\t// 200 moves are possible\\n\\tprivate static String longString1;\\n\\t\\n\\t// A long string with many ways to achieve the longest sequence of moves\\n\\t// 180 moves are possible\\n\\tprivate static String longString2;\\n\\t\\n\\t// A long string with many different paths but not all of them are optimal\\n\\t// 180 moves are possible\\n\\tprivate static String longString3;\\n\\t\\n\\t// A long string where no moves are possible\\n\\t// No moves are possible\\n\\tprivate static String longString4;\\n\\t\\n\\t\\n\\t@BeforeClass\\n\\tpublic static void setup() {\\n\\t\\t\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\tfor (int i=0; i<200; i++) {\\n\\t\\t\\tsb.append(\\\"act\\\");\\n\\t\\t}\\n\\t\\tfor (int i=0; i<200; i++) {\\n\\t\\t\\tsb.append(\\\"or\\\");\\n\\t\\t}\\n\\t\\tlongString1 = sb.toString();\\n\\t\\t\\n\\t\\tsb = new StringBuilder();\\n\\t\\tfor (int i=0; i<40; i++) {\\n\\t\\t\\tsb.append(\\\"actor\\\");\\n\\t\\t}\\n\\t\\tfor (int i=0; i<100; i++) {\\n\\t\\t\\tsb.append(\\\"intact\\\");\\n\\t\\t}\\n\\t\\tfor (int i=0; i<40; i++) {\\n\\t\\t\\tsb.append(\\\"actor\\\");\\n\\t\\t}\\n\\t\\tlongString2 = sb.toString();\\n\\t\\t\\n\\t\\tsb = new StringBuilder();\\n\\t\\tfor (int i=0; i<80; i++) {\\n\\t\\t\\tsb.append(\\\"act\\\");\\n\\t\\t}\\n\\t\\tfor (int i=0; i<100; i++) {\\n\\t\\t\\tsb.append(\\\"int\\\");\\n\\t\\t}\\n\\t\\tfor (int i=0; i<100; i++) {\\n\\t\\t\\tsb.append(\\\"act\\\");\\n\\t\\t}\\n\\t\\tfor (int i=0; i<80; i++) {\\n\\t\\t\\tsb.append(\\\"or\\\");\\n\\t\\t}\\n\\t\\tlongString3 = sb.toString();\\n\\t\\t\\n\\t\\tsb = new StringBuilder();\\n\\t\\tfor (int i=0; i<200; i++) {\\n\\t\\t\\tsb.append(\\\"or\\\");\\n\\t\\t}\\n\\t\\tfor (int i=0; i<200; i++) {\\n\\t\\t\\tsb.append(\\\"act\\\");\\n\\t\\t}\\n\\t\\tlongString4 = sb.toString();\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test1() {\\n\\t\\tassertEquals(1, Challenge.moves(\\\"intactor\\\"));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test2() {\\n\\t\\tassertEquals(2, Challenge.moves(\\\"actorbintact\\\"));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test3() {\\n\\t\\tassertEquals(3, Challenge.moves(\\\"intintactactororact\\\"));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test4() {\\n\\t\\tassertEquals(0, Challenge.moves(\\\"intor\\\"));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test5() {\\n\\t\\tassertEquals(0, Challenge.moves(\\\"\\\"));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test6() {\\n\\t\\tassertEquals(200, Challenge.moves(longString1));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test7() {\\n\\t\\tassertEquals(180, Challenge.moves(longString2));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test8() {\\n\\t\\tassertEquals(180, Challenge.moves(longString3));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void test9() {\\n\\t\\tassertEquals(0, Challenge.moves(longString4));\\n\\t}\\n\\t\\n}\",\"language\":\"java\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,5,5,5,2,5,5],\"rators\":[\"QS45qu2DFXcCqpAnB\",\"Ym8AjbKGSJooun3nt\",\"Es4eX2stRpyoXeC7f\",\"gXTAie79kiw28tx5u\",\"kLMj98oTwmoibCY4v\",\"KMR6vNzvSKMA2cXnK\"],\"total\":9,\"quality\":[]},\"flags\":0},\"summary\":\"Given a string, a move is made by either removing the substring \\\"actor\\\" or by removing the substring \\\"intact\\\".  Upon removing a substring, a new string is produced, and moves may be made from the new string until no more moves are possible.\\n\\nFor example, given the string \\\"inactortact\\\", one can first remove the substring \\\"actor\\\" to get \\\"intact\\\" and then remove\",\"tags\":[\"strings\",\"interview\",\"data_structures\",\"algorithms\"],\"timestamp\":{\"$date\":1598410131009},\"title\":\"Maximum Removals\",\"quality\":0,\"family\":[{\"_id\":\"fSohszsuqKXYDDjGb\",\"language\":\"java\"}]}}"]