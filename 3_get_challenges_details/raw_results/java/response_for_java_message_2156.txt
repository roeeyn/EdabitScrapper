a["{\"msg\":\"result\",\"id\":\"635\",\"result\":{\"_id\":\"j3pBTZLXSo7JJ2iAy\",\"author\":\"Deep Xavier\",\"authorId\":\"a777e8chPvJkY3tKa\",\"code\":\"public class RightShift {\\n\\tpublic static int shiftToRight(int x, int y) {\\n\\t\\t// recursive code here\\n\\t}\\n}\",\"difficulty\":2.2857142857142856,\"editorId\":\"a777e8chPvJkY3tKa\",\"familyId\":\"zctwoeaiQAFAcbiE4\",\"instructions\":\"The **right shift** operation is similar to **floor division by powers of two**, thus, the process is _repetitive_ and can be done _recursively_. \\n\\nSample calculation using the right shift operator ( `>>` ):\\n```\\n80 >> 3 = floor(80/2^3) = floor(80/8) = 10\\n-24 >> 2 = floor(-24/2^2) = floor(-24/4) = -6\\n-5 >> 1 = floor(-5/2^1) = floor(-5/2) = -3\\n```\\n\\nWrite a function that **mimics** (without the use of **>>**) the right shift operator and returns the result from the two given integers.\\n\\n### Examples\\n```\\nshiftToRight(80, 3) ➞ 10\\n\\nshiftToRight(-24, 2) ➞ -6\\n\\nshiftToRight(-5, 1) ➞ -3\\n\\nshiftToRight(4666, 6) ➞ 72\\n\\nshiftToRight(3777, 6) ➞ 59\\n\\nshiftToRight(-512, 10) ➞ -1\\n```\\n\\n### Notes\\n- There will be no negative values for the second parameter `y`.\\n- This challenge is more like recreating of the **right shift** operation, thus, **the use of the operator directly** is **prohibited**.\\n- You are expected to solve this challenge via **recursion**.\\n- An iterative version of this challenge can be found via this [link](https://edabit.com/challenge/fj6c32nSde3FfYoaC).\\n- A collection of challenges in recursion can be found via this [link] (https://edabit.com/collection/Yx78jEBrKppHBNsoQ).\",\"isFree\":false,\"isHidden\":false,\"lab\":\"import static org.junit.Assert.assertEquals;\\nimport org.junit.Test;\\n\\npublic class RightShiftTests {\\n\\tprivate int[][] numVector = new int[][] {{80, 3}, {-24, 2}, {-5, 1}, {38, 0}, {192, 4}, {4666, 6}, {3777, 6}, {1024, 5}, {-512, 10}};\\n\\tprivate int[] resVector = new int[] {10, -6, -3, 38, 12, 72, 59, 32, -1};\\n\\t\\n\\t@Test\\n\\tpublic void test01() {\\n\\t\\tassertEquals(RightShift.shiftToRight(numVector[0][0], numVector[0][1]), resVector[0]);\\n\\t}\\n\\t\\n\\t@Test\\n\\tpublic void test02() {\\n\\t\\tassertEquals(RightShift.shiftToRight(numVector[1][0], numVector[1][1]), resVector[1]);\\n\\t}\\n\\t\\n\\t@Test\\n\\tpublic void test03() {\\n\\t\\tassertEquals(RightShift.shiftToRight(numVector[2][0], numVector[2][1]), resVector[2]);\\n\\t}\\n\\t\\n\\t@Test\\n\\tpublic void test04() {\\n\\t\\tassertEquals(RightShift.shiftToRight(numVector[3][0], numVector[3][1]), resVector[3]);\\n\\t}\\n\\t\\n\\t@Test\\n\\tpublic void test05() {\\n\\t\\tassertEquals(RightShift.shiftToRight(numVector[4][0], numVector[4][1]), resVector[4]);\\n\\t}\\n\\t\\n\\t@Test\\n\\tpublic void test06() {\\n\\t\\tassertEquals(RightShift.shiftToRight(numVector[5][0], numVector[5][1]), resVector[5]);\\n\\t}\\n\\t\\n\\t@Test\\n\\tpublic void test07() {\\n\\t\\tassertEquals(RightShift.shiftToRight(numVector[6][0], numVector[6][1]), resVector[6]);\\n\\t}\\n\\t\\n\\t@Test\\n\\tpublic void test08() {\\n\\t\\tassertEquals(RightShift.shiftToRight(numVector[7][0], numVector[7][1]), resVector[7]);\\n\\t}\\n\\t\\n\\t@Test\\n\\tpublic void test09() {\\n\\t\\tassertEquals(RightShift.shiftToRight(numVector[8][0], numVector[8][1]), resVector[8]);\\n\\t}\\n}\",\"language\":\"java\",\"quality\":0,\"stats\":{\"completed\":{\"ratings\":[2,2,2,2,2,2,4,2,1,4,2,2,2,4,3,3,2,2,3,1,1],\"quality\":[],\"rators\":[\"a777e8chPvJkY3tKa\",\"Es4eX2stRpyoXeC7f\",\"kabqCExooax4JEQHE\",\"Yp7uvStL97cC9fKkY\",\"Ym8AjbKGSJooun3nt\",\"87Q3XMWaxYqQfFJzm\",\"gXTAie79kiw28tx5u\",\"bTCq6CQ3SGjrRfZeQ\",\"RAEFpazbe6mhx3PLb\",\"jyoLggHk8xQKZuoQC\",\"wjPSkPpsFGWYWwFBb\",\"ETHQTGrsqpa4Cq5tk\",\"PjKySrTz5LbQTSe34\",\"qaPjAANdnxFnWfj5d\",\"GvLLKHi7NwAjutdDk\",\"sxci7DYKNa6q22Sjq\"],\"total\":19},\"flags\":0},\"summary\":\"The right shift operation is similar to floor division by powers of two, thus, the process is repetitive and can be done recursively.\\n\\nSample calculation using the right shift operator ( >> ):\\n80 >> 3 = floor(80/2^3) = floor(80/8) = 10\\n-24 >> 2 = floor(-24/2^2) = floor(-24/4) = -6\\n-5 >> 1 = floor(-5/2^1) = floor(-5/2) = -3\\n\\nWrite a function that mimics (withou\",\"tags\":[\"recursion\",\"numbers\",\"bit_operations\"],\"timestamp\":{\"$date\":1603130206695},\"title\":\"Recursion: Right Shift by Division\",\"family\":[{\"_id\":\"j3pBTZLXSo7JJ2iAy\",\"language\":\"java\"},{\"_id\":\"CtxRSuGhry3XK7wjh\",\"language\":\"javascript\"},{\"_id\":\"v34oCTbkrceCZjgRE\",\"language\":\"python3\"}]}}"]