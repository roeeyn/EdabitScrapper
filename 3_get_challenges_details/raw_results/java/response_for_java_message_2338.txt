a["{\"msg\":\"result\",\"id\":\"725\",\"result\":{\"_id\":\"hkKL3KuKpAcgcKdp3\",\"author\":\"Nathan Hohnbaum\",\"authorId\":\"Li55JB322ZcMFGna8\",\"code\":\"public class Challenge {\\n\\tpublic static int[][] depthFirstSearch(int[][] graph) {\\n\\t\\treturn new int[0][0];\\n\\t}\\n}\",\"difficulty\":2.8,\"quality\":0,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"Dcn6YKKekYnCpApvm\",\"instructions\":\"A depth-first search of a graph is one way of traversing the nodes of the graph along edges.  When DFS reaches a node for the first time, it marks the node as being reached and then checks its neighbors. Once all of a node's neighbors have been checked, the node is marked as done.  If the starting node is marked as done before all nodes of a graph are reached, an unmarked node is selected and the search continues. The order in which nodes are originally reached provides useful information about the graph.  Another useful source of information is the order in which nodes are marked as done.  This order is different.\\n\\nThe following are examples of graphs along with the order in which nodes are visited using DFS.\\n\\n![Example 1A](https://edabit-challenges.s3.amazonaws.com/1_kDcFM8j.png)\\n\\n![Example 1B](https://edabit-challenges.s3.amazonaws.com/2_kcpjzTt.png)\\n\\n![Example 2A](https://edabit-challenges.s3.amazonaws.com/3_TPMgFOi.png)\\n\\n![Example 2B](https://edabit-challenges.s3.amazonaws.com/4_eQUGby8.png)\\n\\n![Example 3A](https://edabit-challenges.s3.amazonaws.com/5_ZiKuKUW.png)\\n\\n![Example 3B](https://edabit-challenges.s3.amazonaws.com/6_HlNXVTM.png)\\n\\n### Instructions\\nGiven a graph represented by an adjacency matrix, perform a depth-first search.  When multiple options exist for which node to move to (either selecting a starting node or when a node has multiple neighbors), move to the lowest numbered, unvisited node.\\n\\nYour program will output a 2-dimensional array with two rows.  The first row will record the order in which nodes are initially reached while the second row indicates the order in which the nodes are marked as done.  The columns represent the nodes, and the numbers indicate the order (beginning with 1) in which the nodes are originally visited/marked as done.\\n\\n### Example #1\\n![Example 1A](https://edabit-challenges.s3.amazonaws.com/7_kDcFM8j.png)\\n\\n```\\n{\\n  {0,1,1,0,0,0},\\n  {1,0,0,1,0,0},\\n  {1,0,0,0,1,1},\\n  {0,1,0,0,0,0},\\n  {0,0,1,0,0,0},\\n  {0,0,1,0,0,0}\\n} ➞ {\\n  {1,2,4,3,5,6},\\n  {6,2,5,1,3,4}\\n}\\n```\\n\\n### Example #2\\n![Example 2A](https://edabit-challenges.s3.amazonaws.com/8_TPMgFOi.png)\\n\\n```\\n{\\n  {0,1,1,1,0,1},\\n  {1,0,0,1,1,0},\\n  {1,0,0,0,0,1},\\n  {1,1,0,0,1,0},\\n  {0,1,0,1,0,0},\\n  {1,0,1,0,0,0}\\n} ➞ {\\n  {1,2,5,3,4,6},\\n  {6,3,5,2,1,4}\\n}\\n```\\n\\n### Example #3\\n![Example 3A](https://edabit-challenges.s3.amazonaws.com/9_ZiKuKUW.png)\\n\\n```\\n{\\n  {0,1,1,0,0,0,0},\\n  {1,0,0,0,0,1,0},\\n  {1,0,0,0,0,1,0},\\n  {0,0,0,0,1,0,1},\\n  {0,0,0,1,0,0,1},\\n  {0,1,1,0,0,0,0},\\n  {0,0,0,1,1,0,0}\\n} ➞ {\\n  {1,2,4,5,6,3,7},\\n  {4,3,1,7,6,2,5}\\n}\\n```\\n\\n### Notes\\n- Graphs contain between 1 and 1000 nodes.\\n- Time limit: 100 milliseconds.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"import static org.junit.Assert.*;\\nimport org.junit.*;\\n\\npublic class DFSTest {\\n\\t\\n\\tprivate static int[][] graph1;\\n\\tprivate static int[][] graph2;\\n\\tprivate static int[][] graph3;\\n\\tprivate static int[][] singleNode;\\n\\tprivate static int[][] largeGraph;\\n\\t\\n\\tprivate static int[][] solution1;\\n\\tprivate static int[][] solution2;\\n\\tprivate static int[][] solution3;\\n\\tprivate static int[][] singleNodeSolution;\\n\\tprivate static int[][] largeSolution;\\n\\t\\n\\t@BeforeClass\\n\\tpublic static void setup() {\\n\\t\\tgraph1 = new int[][] {\\n\\t\\t\\t{0,1,1,0,0,0},\\n\\t\\t  {1,0,0,1,0,0},\\n\\t\\t  {1,0,0,0,1,1},\\n\\t\\t  {0,1,0,0,0,0},\\n\\t\\t  {0,0,1,0,0,0},\\n\\t\\t  {0,0,1,0,0,0}\\n\\t\\t};\\n\\t\\tgraph2 = new int[][] {\\n\\t\\t\\t{0,1,1,1,0,1},\\n  \\t\\t{1,0,0,1,1,0},\\n  \\t\\t{1,0,0,0,0,1},\\n\\t\\t  {1,1,0,0,1,0},\\n  \\t\\t{0,1,0,1,0,0},\\n  \\t\\t{1,0,1,0,0,0}\\n\\t\\t};\\n\\t\\t\\n\\t\\tgraph3 = new int[][] {\\n\\t\\t\\t{0,1,1,0,0,0,0},\\n\\t\\t\\t{1,0,0,0,0,1,0},\\n\\t\\t\\t{1,0,0,0,0,1,0},\\n\\t\\t\\t{0,0,0,0,1,0,1},\\n\\t\\t\\t{0,0,0,1,0,0,1},\\n\\t\\t\\t{0,1,1,0,0,0,0},\\n\\t\\t\\t{0,0,0,1,1,0,0}\\n\\t\\t};\\n\\t\\t\\n\\t\\tsingleNode = new int[1][1];\\n\\t\\t\\n\\t\\tlargeGraph = new int[1000][1000];\\n\\t\\tfor (int i=0; i<largeGraph.length; i++) {\\n\\t\\t\\tfor (int j=i+1; j<largeGraph.length; j++) {\\n\\t\\t\\t\\tlargeGraph[i][j]=1;\\n\\t\\t\\t\\tlargeGraph[j][i]=1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tsolution1 = new int[][] {\\n\\t\\t\\t{1,2,4,3,5,6},\\n\\t\\t\\t{6,2,5,1,3,4}\\n\\t\\t};\\n\\t\\t\\n\\t\\tsolution2 = new int[][] {\\n\\t\\t\\t{1,2,5,3,4,6},\\n\\t\\t  {6,3,5,2,1,4}\\n\\t\\t};\\n\\t\\t\\n\\t\\tsolution3 = new int[][] {\\n\\t\\t\\t{1,2,4,5,6,3,7},\\n\\t\\t  {4,3,1,7,6,2,5}\\n\\t\\t};\\n\\t\\t\\n\\t\\tsingleNodeSolution = new int[][] {\\n\\t\\t\\t{1},\\n\\t\\t\\t{1}\\n\\t\\t};\\n\\t\\t\\n\\t\\tlargeSolution = new int[2][largeGraph.length];\\n\\t\\tfor (int i=0; i<largeGraph.length; i++) {\\n\\t\\t\\tlargeSolution[0][i]=i+1;\\n\\t\\t\\tlargeSolution[1][i]=largeGraph.length-i;\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void testGraph1() {\\n\\t\\tassertEquals(solution1, Challenge.depthFirstSearch(graph1));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void testGraph2() {\\n\\t\\tassertEquals(solution2, Challenge.depthFirstSearch(graph2));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void testGraph3() {\\n\\t\\tassertEquals(solution3, Challenge.depthFirstSearch(graph3));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void testSingleNode() {\\n\\t\\tassertEquals(singleNodeSolution, Challenge.depthFirstSearch(singleNode));\\n\\t}\\n\\t\\n\\t@Test(timeout=100)\\n\\tpublic void testLargeGraph() {\\n\\t\\tassertEquals(largeSolution, Challenge.depthFirstSearch(largeGraph));\\n\\t}\\n\\t\\n}\",\"language\":\"java\",\"stats\":{\"completed\":{\"ratings\":[2,2,2,2,2,2,5,5,2,4],\"quality\":[],\"rators\":[\"Li55JB322ZcMFGna8\",\"TrquEHytntLKHA4m2\",\"KooD342x6eT6YiQn8\",\"gXTAie79kiw28tx5u\",\"QfjvAWZnumxpSYpzQ\"],\"total\":5},\"flags\":0},\"summary\":\"A depth-first search of a graph is one way of traversing the nodes of the graph along edges.  When DFS reaches a node for the first time, it marks the node as being reached and then checks its neighbors. Once all of a node's neighbors have been checked, the node is marked as done.  If the starting node is marked as done before all nodes of a graph are reached,\",\"tags\":[\"math\",\"algorithms\",\"data_structures\"],\"timestamp\":{\"$date\":1600123386931},\"title\":\"Depth First Traversal\",\"family\":[{\"_id\":\"hkKL3KuKpAcgcKdp3\",\"language\":\"java\"}]}}"]