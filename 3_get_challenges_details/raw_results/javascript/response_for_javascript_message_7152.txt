a["{\"msg\":\"result\",\"id\":\"2318\",\"result\":{\"_id\":\"9DfcynL8hYqay9PrZ\",\"author\":\"David Newman\",\"authorId\":\"Po3v3dHCk6wYGKMwi\",\"code\":\"function findTreeHeight(root){\\n\\treturn 'Haha I dunno';\\n}\",\"difficulty\":3.75,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"M8AGfjemnirWBSriL\",\"instructions\":\"A [Tree](https://en.wikipedia.org/wiki/Tree_(data_structure)) is a special type of data structure in programming where each element (called a \\\"node\\\") may contain a reference to one or more child elements (again, \\\"nodes\\\"). The maximum number of children that a single node points to may be indicated by the phrase \\\"*n*-ary tree\\\", where *n* is that maximum number. Confused? Let's look at some examples, starting with a *1-ary* tree.\\n\\n#### 1-Ary Tree\\nIf the maximum number of child elements each node can 'point' to is 1, we call this a 1-ary tree:\\n\\n```\\nNodeA ---> NodeB ---> NodeC --> NodeD\\n```\\nIn other words, `NodeA` has a reference to its child element `NodeB`, and `NodeB` has a \\n*its* child element `NodeC`, and so on. Because each element has at most 1 and only 1 child, this is a 1-ary tree (also known as a linked list). \\n\\n#### 2-Ary Tree\\n\\nIf the maximum number of child elements each node can 'point' to is 2, we call this a 2-ary tree, or a *bi*nary tree (from Latin *bis*, meaning \\\"two\\\" or \\\"twice\\\"). Here's a quick example:\\n```\\n     A\\n   /  \\\\\\n  B    C\\n /    / \\\\\\nD    E   F\\n     \\\\\\n      G\\n```\\n\\nRemember that the *n* term is the *maximum* number of children for each node; node B and E only have 1 child, and nodes D, F, and G have 0 children.\\n\\n### Navigating an n-ary tree.\\n\\nWhen given an n-ary tree, you're normally given the root node (`A` in the case of my binary tree above). The only way to access nodes other than this root would be to **recursively** \\\"ask\\\" for those nodes:\\n```\\nGiven: root(A), we wanna find E's value:\\n1. Get A's child C\\n2. We're now on node C.\\n3. Get C's child E.\\n4. We're now on node E.\\n```\\nIn other words, given root node `A` above, *we cannot simply jump directly to node E*. Instead, we've gotta jump down from grandparent to parent to child, and so on, until we reach our desired node.\\n\\n----\\n\\n### Your Goal\\nGiven an n-ary tree, return the *maximum height* (or put more simply, just the height!) of the tree. For my binary tree above, you'd want to return `4`. Think of it this way: what's the longest path you could follow, from parent to child to grandchild and so on, without ever going back \\\"up\\\" the tree?\\n\\n\\n### Examples\\n```\\nIn:\\n     A\\n   /  \\\\\\n  B    C\\n /    / \\\\\\nD    E   F\\n     \\\\\\n      G \\nOut: 4 (A,C,E,G)\\n\\nIn:    E --> D --> A --> B --> I --> T\\nOut: 6 (E,D,A,B,I,T)\\n\\nIn:   \\n    A\\n  / | \\\\\\n B  C  D\\n/       \\\\\\nE        H\\n\\\\\\n F\\n/\\nG \\nOut: 5 (A,B,E,F,G)\\n```\\n\\n### Notes and Suggestions\\n - For anyone wondering, the trees are not necessarily either balanced or ordered. \\n - Similarly, the values of each node are trivial for this exercise. They're really only used so that I can construct the initial trees for you.\\n - You are *only* required to return the maximum height. The sequences of nodes included in the examples are for illustrative purposes only!\\n - As the tag for this exercise indicates, one of the \\\"usual\\\" solutions for this exercise is a *recursive* one. If you *really* wanna impressive everyone, there is an iterative solution too!\\n - As usual, please point out any bugs in the tests (or suggest new ones!).\\n - There are specific names for other \\\"levels\\\" of n:\\n     - 1: unary tree\\n     - 3: ternary tree\\n     - 4: quadtree\\n     - 9: nonary tree\\n     - \ud83c\udf84: Christmas tree\",\"isFree\":false,\"isHidden\":false,\"lab\":\"//Test.assertEquals(actual, expected, message)\\n//Test.assertSimilar(actual, expected, message)\\nclass TreeNode{\\n\\tconstructor(v){\\n\\t\\tthis.val = v;\\n\\t\\tthis.children = [];\\n\\t}\\n}\\n\\nconst constructTree=list=>{\\n\\t//construct an n-ary tree given a list of nodes, where\\n\\t//each node has a parent p and a value v.\\n\\tconst nodes = [];//references to each node\\n\\tlet root=  null;\\n\\twhile(list.length){\\n\\t\\tlet ce = list.shift(),\\n\\t\\t\\t\\tcn = new TreeNode(ce.v);\\n\\t\\tif(ce.p!==-1){\\n\\t\\t\\t//non-root\\n\\t\\t\\tlet parent = nodes.find(q=>q.val==ce.p);\\n\\t\\t\\tif(!parent) throw new Error('PARENT NOT FOUND');\\n\\t\\t\\tparent.children.push(cn);\\n\\t\\t}else{\\n\\t\\t\\troot=cn;\\n\\t\\t}\\n\\t\\tnodes.push(cn);\\n\\t}\\n\\treturn root;\\n}\\n\\nconst tests = [{\\n    list:[{p:-1,v:'A'},{p:'A',v:'B'},{p:'A',v:'C'},{p:'B',v:'d'},{p:'C',v:'E'},{p:'C',v:'F'},{p:'E',v:'G'}],\\n    expected:4,\\n    order:2\\n},{\\n    list:[{p:-1,v:'E'},{p:'E',v:'D'},{p:'D',v:'A'},{p:'A',v:'B'},{p:'B',v:'I'},{p:'I',v:'T'}],\\n    expected:6,\\n    order:1\\n},{\\n    list:[{p:-1,v:'A'},{p:'A',v:'B'},{p:'A',v:'C'},{p:'A',v:'D'},{p:'C',v:'H'},{p:'B',v:'E'},{p:'E',v:'F'},{p:'F',v:'G'}],\\n    expected:5,\\n    order:3\\n},{\\n\\tlist:[],\\n\\texpected:0,\\n\\torder:0\\n},{\\n    list:[{p:-1,v:'A'},{p:'A',v:'B'},{p:'A',v:'C'},{p:'A',v:'D'},{p:'A',v:'E'},{p:'A',v:'F'},{p:'A',v:'G'},{p:'A',v:'H'},{p:'A',v:'I'},{p:'A',v:'J'}],\\n    expected:2,\\n    order:9\\n},{\\n\\tlist:[{p:-1,v:'im just a sappling'}],\\n\\texpected:1,\\n\\torder:0\\n},{\\n    list:[{p:-1,v:'A'},{p:'A',v:'B'},{p:'A',v:'C'},{p:'B',v:'D'},{p:'B',v:'E'},{p:'C',v:'F'},{p:'D',v:'G'},{p:'F',v:'H'},{p:'H',v:'I'},{p:'C',v:'J'},{p:'B',v:'K'},{p:'H',v:'L'},{p:'G',v:'M'}],\\n    expected:5,\\n    order:3\\n}];\\n\\ntests.forEach(test=>{\\n\\tlet tree = constructTree(test.list), height = findTreeHeight(tree);\\n\\tTest.assertEquals(height,test.expected,`Wrong height! Tree was a ${test.order}ary tree.`)\\n})\",\"language\":\"javascript\",\"quality\":0,\"stats\":{\"completed\":{\"ratings\":[4,4,4,4,4,4,5,1],\"quality\":[],\"rators\":[\"Po3v3dHCk6wYGKMwi\",\"mDWNyaaQ9hvPCRzSd\",\"yjtdwc2AC4jA2RWtn\"],\"total\":6},\"flags\":0},\"summary\":\"A Tree) is a special type of data structure in programming where each element (called a \\\"node\\\") may contain a reference to one or more child elements (again, \\\"nodes\\\"). The maximum number of children that a single node points to may be indicated by the phrase \\\"n-ary tree\\\", where n is that maximum number. Confused? Let's look at some examples, starting with a 1-\",\"tags\":[\"recursion\",\"data_structures\"],\"timestamp\":{\"$date\":1609453552873},\"title\":\"N-ary Tree Height\",\"family\":[{\"_id\":\"9DfcynL8hYqay9PrZ\",\"language\":\"javascript\"}]}}"]