a["{\"msg\":\"result\",\"id\":\"2046\",\"result\":{\"_id\":\"oxmSTZABggZt7A8td\",\"author\":\"er0s\",\"authorId\":\"5Zq3aGdvh4LHBvnJL\",\"code\":\"function itinerary(start, toVisit) {\\n\\t\\n}\\n\\nclass GPS {\\n\\tstatic decimal(degrees, minutes, seconds, direction) {\\n\\t\\t\\n\\t}\\n\\tstatic radians(decimal) {\\n\\t\\t\\n\\t}\\n\\tstatic distance(cityA, cityB) {\\n\\t\\n\\t}\\n}\\n\\nconst cities = {\\n\\t\\\"London\\\": `51° 30' 30\\\" N 0° 7' 32\\\" W`,\\n\\t\\\"New York\\\": `40° 42' 51\\\" N 74° 0' 21\\\" W`,\\n\\t\\\"Kitchener\\\": `43° 27' 10\\\" N 80° 29' 42\\\" W`,\\n\\t\\\"Los Angeles\\\": `34° 3' 8\\\" N 118° 14' 37\\\" W`,\\n\\t\\\"Naples\\\": `40° 51' 46\\\" N 14° 16' 36\\\" E`,\\n\\t\\\"Moscow\\\": `55° 45' 7\\\" N 37° 36' 56\\\" E`,\\n\\t\\\"Beijing\\\": `39° 54' 27\\\" N 116° 23' 50\\\" E`,\\n\\t\\\"Tokyo\\\": `35° 41' 22\\\" N 139° 41' 30\\\" E`,\\n\\t\\\"Quito\\\": `0° 13' 47\\\" S 78° 31' 29\\\" W`,\\n\\t\\\"Buenos Aires\\\": `34° 36' 30\\\" S 58° 22' 19\\\" W`,\\n\\t\\\"Rio de Janeiro\\\": `22° 54' 10\\\" S 43° 12' 27\\\" W`,\\n\\t\\\"Montevideo\\\": `35° 54' 11\\\" S 56° 11' 17\\\" W`,\\n\\t\\\"Johannesburg\\\": `26° 12' 8\\\" S 28° 2' 37\\\" E`,\\n\\t\\\"Jakarta\\\": `6° 12' 52\\\" S 106° 50' 42\\\" E`,\\n\\t\\\"Sidney\\\": `33° 52' 4\\\" S 151° 12' 26\\\" E`,\\n\\t\\\"Auckland\\\": `36° 52' 0\\\" S 174° 46' 0\\\" E`\\n}\\n\\nconst EARTH_RADIUS_IN_KM = 6371\",\"difficulty\":2.869565217391304,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"dft2CMWYkrDy5EHYK\",\"instructions\":\"In this challenge, use the **haversine formula** to calculate the distances between various cities and establish an itinerary for a series of cities to visit. You have to build an _utility_ class `GPS` that supports a function `itinerary`.\\n\\n### The utility class `GPS`\\nThe class `GPS` must have three static methods:\\n- `.decimal()`  transforms a DMS coordinate into a **decimal coordinate**: as parameters, it accepts **three integers** which are the `degrees`, the `minutes` and the `seconds` and a **capital letter** to represent the `cardinal direction`.\\n- `.radians()` transforms a decimal coordinate into **radians**: as parameter, it accepts a decimal coordinate as a **float number**.\\n- `.distance()` calculates the shortest distance (in kilometers) between two given cities using the **haversine formula** and a constant **radius of the Earth equal to 6371km**, rounding the result down to the nearest integer: as parameters, it accepts **two full DMS string coordinates**.\\n\\n```\\nLondon: 51° 30' 30\\\" N 0° 7' 32\\\" W\\nSidney: 33° 52' 4\\\" S 151° 12' 26\\\" E\\n\\nGPS.decimal(51, 30, 30, \\\"N\\\") ➞ 51.50833333333333\\nGPS.decimal(0, 7, 32, \\\"W\\\") ➞ -0.12555555555555556\\n// London's decimal latitude and longitude.\\n// West coordinates are negatives.\\n\\nGPS.decimal(33, 52, 4, \\\"S\\\") ➞ -33.867777777777775\\nGPS.decimal(151, 12, 26, \\\"E\\\") ➞ 151.2072222222222\\n// Sidney's decimal latitude and longitude.\\n// South coordinates are negatives.\\n\\nGPS.radians(-0.12555555555555556) ➞ -0.002191357838615103\\n// London's longitude in radians\\n\\nGPS.radians(151.2072222222222) ➞ 2.6390638805725146\\n// Sidney's longitude in radians.\\n\\nGPS.distance('51° 30' 30\\\" N 0° 7' 32\\\" W', '33° 52' 4\\\" S 151° 12' 26\\\" E') ➞ 16993\\n// Shortest distance between London and Sidney (in kilometers).\\n```\\n\\n### The function `itinerary`\\n\\nGiven a starting city `start` and an array of cities `toVisit`, implement a function that returns an array with two elements:\\n- A sub-array containing the cities (the first one will always be the `start` city) to visit, in the order given by **the shortest distance from the last visited city**;\\n- An integer being the total number of kilometers necessary to complete the travel.\\n\\nLet's suppose that **@Matt** decides to see Moscow, Sidney, Buenos Aires and Los Angeles. He starts his travel from Kitchener and the nearest city is Los Angeles (3,403 km). From Los Angeles, he goes to Moscow (9,769 km). From Moscow, the nearest city is Buenos Aires (13,475 km). From Buenos Aires, Matt ends his travel in Sidney (11,801 km). The result with the itinerary and the total kilometers is:\\n\\n```\\n[[\\\"Kitchener\\\", \\\"Los Angeles\\\", \\\"Moscow\\\", \\\"Buenos Aires\\\", \\\"Sidney\\\"], 38448]\\n```\\n\\n### Examples\\n```\\nitinerary(\\\"Naples\\\", [\\\"New York\\\", \\\"Johannesburg\\\", \\\"Beijing\\\", \\\"Quito\\\"]) ➞ [[\\\"Naples\\\", \\\"New York\\\", \\\"Quito\\\", \\\"Johannesburg\\\", \\\"Beijing\\\"], 35001]\\n\\nitinerary(\\\"Tokyo\\\", [\\\"London\\\", \\\"Montevideo\\\", \\\"Jakarta\\\", \\\"Auckland\\\"]) ➞ [[\\\"Tokyo\\\", \\\"Jakarta\\\", \\\"Auckland\\\", \\\"Montevideo\\\", \\\"London\\\"], 34931]\\n\\nitinerary(\\\"Rio de Janeiro\\\", [\\\"Naples\\\", \\\"New York\\\", \\\"Sidney\\\", \\\"Kitchener\\\"]) ➞ [[\\\"Rio de Janeiro\\\", \\\"New York\\\", \\\"Kitchener\\\", \\\"Naples\\\", \\\"Sidney\\\"], 31897]\\n```\\n\\n### Notes\\n- The coordinates of the cities are stored in an object literal `cities` in the **Code** tab, as well as the constant for the radius of the Earth (in this challenge, is **6371Km**).\\n- The given data will be always valid, without exceptions to handle. The format for full DMS coordinates will be always like `140° 1' 59\\\" N 99° 59' 1 E\\\"` (no leading zeros or negative values, values separated by a space, capital letters for the four cardinal directions).\\n- Do not round decimal coordinates or radians. Round distances **down** to the nearest integer.\\n- The decimal (and radians) values of `W` (West) and `S` (South) coordinates are negatives.\\n- Obviously, the distances are intented _as the crow flies_, hypotizing a _flat_ surface.\\n- Look at the **Resources** tab for a series of useful links about all the arguments of this challenge.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"// DMS coordinate to decimal coordinate\\nTest.assertEquals(GPS.decimal(51, 30, 30, \\\"N\\\"), 51.50833333333333);\\nTest.assertEquals(GPS.decimal(58, 22, 19, \\\"W\\\"), -58.371944444444445);\\n\\n// Decimal coordinate to radians\\nTest.assertEquals(GPS.radians(51.50833333333333), 0.8989900088814126);\\nTest.assertEquals(GPS.radians(-58.371944444444445), -1.018782621346768);\\n\\n// Distance between two cities\\nTest.assertEquals(GPS.distance(cities[\\\"London\\\"], cities[\\\"New York\\\"]), 5570);\\nTest.assertEquals(GPS.distance(cities[\\\"Sidney\\\"], cities[\\\"Los Angeles\\\"]), 12073);\\nTest.assertEquals(GPS.distance(cities[\\\"Rio de Janeiro\\\"], cities[\\\"Beijing\\\"]), 17322);\\nTest.assertEquals(GPS.distance(cities[\\\"Moscow\\\"], cities[\\\"Johannesburg\\\"]), 9158);\\n\\n// Travel itinerary\\nTest.assertSimilar(itinerary(\\\"Naples\\\", [\\\"New York\\\", \\\"Johannesburg\\\", \\\"Beijing\\\", \\\"Quito\\\"]),\\n\\t[ [ 'Naples', 'New York', 'Quito', 'Johannesburg', 'Beijing' ], 35001 ]);\\n\\nTest.assertSimilar(itinerary(\\\"Kitchener\\\", [\\\"Buenos Aires\\\", \\\"Sidney\\\", \\\"Los Angeles\\\", \\\"Moscow\\\"]),\\n\\t[ [ 'Kitchener', 'Los Angeles', 'Moscow', 'Buenos Aires', 'Sidney' ], 38448 ]);\\n\\nTest.assertSimilar(itinerary(\\\"Tokyo\\\", [\\\"London\\\", \\\"Montevideo\\\", \\\"Jakarta\\\", \\\"Auckland\\\"]),\\n\\t[ [ 'Tokyo', 'Jakarta', 'Auckland', 'Montevideo', 'London' ], 34931 ]);\\n\\nTest.assertSimilar(itinerary(\\\"Rio de Janeiro\\\", [\\\"Naples\\\", \\\"New York\\\", \\\"Sidney\\\", \\\"Kitchener\\\"]),\\n\\t[ [ 'Rio de Janeiro', 'New York', 'Kitchener', 'Naples', 'Sidney' ], 31897 ]);\\n\\nTest.assertSimilar(itinerary(\\\"Moscow\\\", [\\\"Jakarta\\\", \\\"Montevideo\\\", \\\"Beijing\\\", \\\"London\\\"]),\\n\\t[ [ 'Moscow', 'London', 'Beijing', 'Jakarta', 'Montevideo' ], 30868 ]);\\n\\nTest.assertSimilar(itinerary(\\\"Buenos Aires\\\", [\\\"Quito\\\", \\\"Los Angeles\\\", \\\"London\\\", \\\"Naples\\\"]),\\n\\t[ [ 'Buenos Aires', 'Quito', 'Los Angeles', 'London', 'Naples' ], 20352 ]);\",\"language\":\"javascript\",\"stats\":{\"completed\":{\"ratings\":[3,3,3,3,3,3,5,4,2,1,0,5,3,4,0,2,4,4,3,4,3,3,1],\"rators\":[\"5Zq3aGdvh4LHBvnJL\",\"knxCMCGP3rAkiatRo\",\"yjtdwc2AC4jA2RWtn\",\"hcm8sL8mNJTSfTdgE\",\"AMKkrzLGTmCKQD2fZ\",\"MNDLmXZmFMf8ASL2L\",\"mHT2bJb5SByfJ8yKS\",\"vt88eKvFz6ES8sbrD\",\"aEm3Wvj2rFYRL8Lrb\",\"Ygy4NA6ih4QK7DpmJ\",\"iJC8PmpzSyTnEDqw5\",\"65dbBZynphj53nXqA\",\"KxAo9fszavsKNDZvL\",\"c7uBxu2rgY77H5d79\",\"pGh7WykiPe26fHJYv\",\"KcpfY4XZ7fNamyLd3\",\"Ek9PiwGewEGH6fcqz\",\"YLTZRjM78Wi9J9Re4\",\"yr822PZmmiDDenxpB\"],\"total\":24,\"quality\":[5]},\"flags\":0},\"summary\":\"In this challenge, use the haversine formula to calculate the distances between various cities and establish an itinerary for a series of cities to visit. You have to build an utility class GPS that supports a function itinerary.\\n\\nThe utility class GPS\\nThe class GPS must have three static methods:\\n.decimal()  transforms a DMS coordinate into a decimal coordina\",\"tags\":[\"data_structures\",\"classes\",\"math\",\"geometry\"],\"timestamp\":{\"$date\":1583359130422},\"title\":\"The GPS Itinerary: Around the World\",\"quality\":5,\"family\":[{\"_id\":\"oxmSTZABggZt7A8td\",\"language\":\"javascript\"}]}}"]