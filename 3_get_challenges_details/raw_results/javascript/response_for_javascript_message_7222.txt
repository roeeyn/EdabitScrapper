a["{\"msg\":\"result\",\"id\":\"2352\",\"result\":{\"_id\":\"RC8PZp77Mdfh27HTa\",\"author\":\"David Newman\",\"authorId\":\"Po3v3dHCk6wYGKMwi\",\"code\":\"// Construct your Trie class here!\\n\\nfunction autosuggest({s:searches,i:input}){\\n\\t// arguments: \\n\\t//\\t\\tsearches: list of possible returned words/phrases\\n\\t//\\t\\tinput: your \\\"user's\\\" input.\\n\\t// return your autocomplete list here!\\n\\t\\n}\",\"difficulty\":3.923076923076923,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"ivwApYQgPRiBP35uD\",\"instructions\":\"A **trie** (pronounced \\\"try\\\") is a particular type of tree data structure that breaks a word (or another similar linear bit of data) into individual pieces (i.e., letters) and then stores that broken-up word in a way that *similar* words are computationally easy (== quick)  to find. Confused? Look at the following example trie:\\n\\n```\\n    words: car, cats, coat\\n        . <--- Root node\\n       /  \\\\\\n      c   (other stuff)\\n     / \\\\\\n    a   o\\n   / \\\\    \\\\\\n r*   t     a\\n       \\\\     \\\\\\n       s*     t\\n * = end of a word\\n```\\n\\nTo find whether our trie contains a particular word, we start at the root node. We then check each letter in our candidate word sequentially, checking to see whether our current node has any children that match that letter. Let's do an example with the word \\\"cats\\\":\\n1. Start at the root node.\\n2. Take the first letter of 'cats', `c`.\\n3. Does the root node have a child node that matches `c`? Yes!\\n4. Move to the `c` node.\\n5. Take the second letter of 'cats', `a`.\\n6. Does the root node have a child node that matches `a`? Yes!\\n7. And so on.\\n\\nThere are two things to note here:\\n\\n1. While there are actually two `a`s that are \\\"descendants\\\" of our initial `c`, only one \\\"works\\\". We're only interested in immediate children here, not grandchildren or great-grandchildren!\\n2. Every letter that \\\"finishes\\\" a word must have a particular flag (I've designated these with a `*` above) that indicates that it's the end of a word. As such, while the word \\\"cat\\\" *is* a legitimate, acceptable English word, it's not part of our trie: searching for \\\"cat\\\" in our trie should return false, as the `t` in \\\"cat\\\" does *not* have the \\\"finishes a word\\\" flag set to true.\\n\\n### Trie-ing Times (Use Cases)\\nOne of the most common uses of Tries in the real world is in auto-suggests. You've seen this (occasionally probably to your confusion/amusement) in search engines like Google when typing in a word or phrase. Google will attempt to fill in the rest of your search query before you even finish typing it! Let's trie to think about how that might work:\\n\\nWhile it could just search through literally every search that's ever been submitted, that's pretty slow. Instead, it (probably!) uses a trie or trie-like structure. So let's say you type \\\"c\\\". Google will then say \\\"okay, only include queries beginning with the letter 'c'\\\". Next, you type \\\"a\\\". Google says \\\"alrighty, only include words with the letters 'ca'\\\". And so on, until you either finish typing your query *or* click one of the suggested queries.\\n\\nThat's what you're going to be doing here.\\n\\n### Trie It Yourself (Instructions)\\nHere's what you'll need to do:\\n\\n1. You'll be given a list of words and/or phrases, `searches`, as well as a string of text `input` representing what the user has currently entered.\\n2. Using a `Trie` class, for the given `input`, determine what the autosuggest should say, sorted alphabetically.\\n3. It's up to you how exactly you structure your `Trie` class. However, keep in mind that you'll need an `addWord()` method to add words to your trie, and a `hasWord()` to detect if your trie contains a particular word.\\n4. One of the tests will use your Trie class constructor directly!\\n5. Make sure to use the provided `autosuggest()` function to actually *run* your Trie stuff.\\n\\n### Notes\\n - For the sake of simplicity, only consider search terms that *start* with your given input.\\n - All strings will consist only of lowercase letters and spaces.\\n - Despite the name of this challenge, you're perfectly welcome to use a `do...while` loop if you feel that would benefit you.\\n - Not *everything* outlined in the \\\"Explanation\\\" section above may be needed, depending on your solution!\\n - My solution uses a Depth-First Search based algorithm. Yours may need to also!\\n - It is *entirely* possible to \\\"cheat\\\" this challenge and simply return a hard-coded list of all \\\"correct\\\" answers. However, that's not really the point here. Shame on cheaters!\",\"isFree\":false,\"isHidden\":false,\"lab\":\"const tests = [{\\n    s: ['apple', 'dog', 'cat', 'category', 'car', 'crag', 'scatter', 'cast', 'captain america', 'caligula was a weird dude', 'excavate'],\\n    i: 'ca',\\n    m: 'A simple search!',\\n    e: ['cat','category','car','cast','captain america','caligula was a weird dude']\\n}, {\\n    s: ['potato', 'dog', 'bog', 'box', 'bole', 'bolling', 'bold', 'bolivia', 'bottom', 'bottomless', 'boldness'],\\n    i: 'bol',\\n    m: 'Works with three letter inputs too!',\\n    e: ['bole','bolling','bold','bolivia','boldness']\\n}, {\\n    s: ['hackerrank', 'leetcode', 'codewars', 'codeingame', 'w3schools', 'codeacademy'],\\n    i: 'ed',\\n    m: 'Sometimes returns nothing!',\\n    e: []\\n}, {\\n    s: [\\\"don't do that\\\", \\\"do or do not there is no try\\\", \\\"do unto others as youd have them do unto you\\\", \\\"doobee doobee doo\\\", \\\"whom do you serve?\\\"],\\n    i: 'do ',\\n    m: 'Works with spaces!',\\n    e: ['do or do not there is no try','do unto others as youd have them do unto you']\\n}]\\n\\nconsole.log(\\\"Does the solution have a Trie class?\\\")\\nTest.assertEquals(typeof Trie,'function',\\\"I can't find your Trie class!\\\")\\nif (typeof Trie != 'function') return false;\\nconsole.log('----')\\nconst tt = new Trie();\\nconsole.log(\\\"Does the Trie class have an addWord() method?\\\")\\nTest.assertEquals(typeof tt.addWord,'function',\\\"Your Trie class doesn't appear to have an addWord() method!\\\")\\nconsole.log('----')\\nconsole.log(\\\"Does the Trie class have a hasWord() method?\\\")\\nTest.assertEquals(typeof tt.hasWord,'function',\\\"Your Trie class doesn't appear to have a hasWord() method!\\\")\\nconsole.log('========')\\ntests.forEach(t=>{\\n\\tconsole.log(t.m);\\n\\tTest.assertSimilar(autosuggest(t),t.e.sort(),`Your autosuggest returned the wrong words!`);\\n\\tconsole.log('----')\\n})\",\"language\":\"javascript\",\"quality\":0,\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,3,2,2,5,0,5,5,4],\"quality\":[],\"rators\":[\"Po3v3dHCk6wYGKMwi\",\"vGKxRcDYDsXzTQuEQ\",\"yjtdwc2AC4jA2RWtn\",\"sNcDN3s3rH9wcNg5n\",\"PH32cNxBjrK4a28sn\",\"ZoRz3G3G4Z8kHuFpb\",\"H7SfrAwjam3jmMNEy\",\"P8bXFR4cHwFia9rNM\"],\"total\":10},\"flags\":0},\"summary\":\"A trie (pronounced \\\"try\\\") is a particular type of tree data structure that breaks a word (or another similar linear bit of data) into individual pieces (i.e., letters) and then stores that broken-up word in a way that similar words are computationally easy (== quick)  to find. Confused? Look at the following example trie:\\n\\n    words: car, cats, coat\\n        .\",\"tags\":[\"data_structures\",\"strings\",\"classes\",\"objects\"],\"timestamp\":{\"$date\":1603152774394},\"title\":\"Trie or Trie not: There Is No \\\"Do\\\"\",\"family\":[{\"_id\":\"RC8PZp77Mdfh27HTa\",\"language\":\"javascript\"}]}}"]