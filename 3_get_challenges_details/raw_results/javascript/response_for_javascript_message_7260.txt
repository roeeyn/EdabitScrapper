a["{\"msg\":\"result\",\"id\":\"2371\",\"result\":{\"_id\":\"JDrFEafj2647uv9Ey\",\"author\":\"Mubashir Hassan \",\"authorId\":\"T6iBEE2jp7f7iEF2P\",\"code\":\"function howManyPaths(arr) {\\n\\t\\n}\",\"difficulty\":4.125,\"familyId\":\"5uipqCiz4fGYq3Pii\",\"instructions\":\"This challenge is an extension of Helen Yu's  [Can You Exit the Maze?](https://edabit.com/challenge/ogDHjfpAcE896kN4H) and [Can You Enter the Cave?](https://edabit.com/challenge/CP5zy4iLZzNy2KFcN). Most of the test cases come from her challenge with a few new ones of my own.\\n\\nInstead of finding a path through the maze, you must find all connected paths - paths where you can walk from one cell to another either by doing up or down or left or right. Not diagonally.\\n\\nThe maze is represented by a 2D matrix, where 0s represent walkable areas, and 1s represents walls.\\n\\nWrite a function that will return the length of the longest connected path (each cell only counts once even if you must re-enter to fully walk the path) and the number of connected paths as a tuple.\\n\\n### Examples\\n```\\nhowManyPaths([\\n  [0, 0, 0, 1, 0, 0, 1, 1],\\n  [0, 1, 0, 1, 0, 0, 0, 1],\\n  [0, 0, 0, 1, 1, 1, 1, 1],\\n  [1, 1, 1, 1, 0, 0, 0, 1],\\n  [1, 0, 1, 1, 0, 0, 0, 1],\\n  [1, 1, 1, 1, 0, 0, 0, 1]\\n]) ➞ [9, 4]\\n\\n// The longest path is in the lower right and there are\\n// four paths, upper left with 8, upper right with 5,\\n// lower left with 1.\\n```\\n\\n```\\nhowManyPaths([\\n  [0, 1, 1, 1, 1, 1, 1, 0],\\n  [0, 0, 0, 0, 0, 0, 0, 0],\\n  [0, 0, 0, 0, 0, 1, 1, 0],\\n  [0, 1, 1, 0, 0, 1, 1, 0]\\n]) ➞ [20, 1]\\n```\\n\\n```\\nhowManyPaths([\\n  [0, 1, 1, 1, 0, 1, 1, 0],\\n  [0, 0, 1, 1, 0, 0, 0, 0],\\n  [0, 0, 0, 0, 1, 1, 1, 0],\\n  [0, 1, 1, 1, 1, 1, 1, 0]\\n]) ➞ [8, 2]\\n```\\n\\n### Notes\\nThis is a variation of a problem where I had to find all groups of connected customers (owners of the same account) across a bank's customer database in preparation to split the bank and 'sell' off some of the customers/accounts.\",\"isFlagged\":false,\"isFree\":false,\"isHidden\":false,\"lab\":\"Test.assertSimilar(howManyPaths([\\n\\t[0, 0, 1, 1, 1, 0, 0, 0], \\n\\t[0, 0, 0, 0, 1, 0, 0, 0], \\n\\t[0, 0, 1, 0, 0, 0, 0, 0], \\n\\t[0, 0, 1, 1, 1, 1, 1, 0]\\n]), [22, 1])\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[0, 0, 0, 1, 0, 0, 0, 0], \\n\\t[0, 0, 0, 1, 1, 0, 0, 0], \\n\\t[0, 0, 0, 0, 1, 1, 0, 0], \\n\\t[0, 0, 0, 1, 1, 1, 1, 0]\\n]), [13, 2])\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[0, 1, 1, 1, 0, 1, 1, 0], \\n\\t[0, 0, 1, 1, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 0, 1, 0, 0], \\n\\t[0, 1, 1, 1, 1, 1, 1, 0]\\n]), [18, 1])\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[0, 1, 1, 1, 0, 1, 1, 0], \\n\\t[0, 0, 1, 1, 0, 0, 0, 0], \\n\\t[0, 0, 0, 1, 0, 1, 0, 0], \\n\\t[0, 1, 1, 1, 1, 1, 1, 0]\\n]), [10, 2])\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[0, 1, 1, 1, 0, 1, 1, 0], \\n\\t[0, 0, 1, 1, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 1, 1, 1, 0], \\n\\t[0, 1, 1, 1, 1, 1, 1, 0]\\n]), [8, 2])\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[0, 1, 1, 1, 1, 1, 1, 0], \\n\\t[0, 0, 0, 0, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 0, 1, 1, 0], \\n\\t[0, 1, 1, 0, 0, 1, 1, 0]\\n]), [20, 1])\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[0, 1, 1, 1, 1, 1, 1, 0], \\n\\t[0, 0, 0, 0, 1, 0, 0, 0], \\n\\t[0, 0, 1, 1, 1, 1, 1, 0], \\n\\t[0, 1, 1, 0, 0, 1, 1, 0]\\n]), [8, 3])\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[0, 1, 1, 1, 1, 1, 1, 0], \\n\\t[0, 1, 0, 0, 1, 0, 0, 0], \\n\\t[0, 0, 1, 0, 1, 1, 1, 0], \\n\\t[0, 1, 1, 0, 0, 1, 1, 0]\\n]), [6, 3])\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[0, 1, 1, 1, 1, 1, 1, 1], \\n\\t[0, 0, 0, 0, 1, 0, 0, 1], \\n\\t[0, 0, 1, 0, 1, 0, 0, 0], \\n\\t[0, 1, 1, 0, 0, 0, 1, 0]\\n]), [18, 1])\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[1, 0, 0, 0, 0, 0, 1, 0, 0], \\n\\t[1, 0, 1, 1, 1, 0, 1, 0, 1], \\n\\t[1, 0, 1, 0, 0, 0, 1, 0, 1], \\n\\t[1, 0, 1, 0, 1, 1, 1, 0, 1],\\n\\t[0, 0, 1, 0, 0, 0, 0, 0, 1]\\n]), [25, 1])\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[1, 1, 1, 1, 1, 1, 1, 1], \\n\\t[1, 1, 1, 1, 1, 1, 1, 1], \\n\\t[1, 1, 1, 1, 1, 1, 1, 1], \\n\\t[1, 1, 1, 1, 1, 1, 1, 1]\\n]), [0, 0])\\n\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[0, 0, 0, 0, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 0, 0, 0, 0], \\n\\t[0, 0, 0, 0, 0, 0, 0, 0]\\n]), [32, 1])\\n\\nTest.assertSimilar(howManyPaths([\\n\\t[0, 0, 0, 1, 0, 0, 1, 1],\\n\\t[0, 1, 0, 1, 0, 0, 0, 1],\\n\\t[0, 0, 0, 1, 1, 1, 1, 1],\\n\\t[1, 1, 1, 1, 0, 0, 0, 1],\\n\\t[1, 0, 1, 1, 0, 0, 0, 1],\\n\\t[1, 1, 1, 1, 0, 0, 0, 1]\\n]), [9, 4])\",\"language\":\"javascript\",\"quality\":0,\"summary\":\"This challenge is an extension of Helen Yu's  Can You Exit the Maze? and Can You Enter the Cave?. Most of the test cases come from her challenge with a few new ones of my own.\\n\\nInstead of finding a path through the maze, you must find all connected paths - paths where you can walk from one cell to another either by doing up or down or left or right. Not diagon\",\"tags\":[\"functional_programming\",\"arrays\"],\"timestamp\":{\"$date\":1607761143441},\"title\":\"How Many Paths?\",\"stats\":{\"completed\":{\"total\":5,\"ratings\":[5,5,5,5,5,2,1,5],\"quality\":[],\"rators\":[\"mDWNyaaQ9hvPCRzSd\",\"yjtdwc2AC4jA2RWtn\",\"bXaGdBM8FBLHf7N6Y\"]},\"flags\":0},\"editorId\":\"BkPgkDQGHm66X4Qai\",\"family\":[{\"_id\":\"DLc7xPX2LRrHZB5H9\",\"language\":\"cpp\"},{\"_id\":\"JDrFEafj2647uv9Ey\",\"language\":\"javascript\"},{\"_id\":\"xTKQ3zYZ7gY7fBpr9\",\"language\":\"python3\"},{\"_id\":\"ezp4q7C7Rqmp2euAe\",\"language\":\"ruby\"}]}}"]