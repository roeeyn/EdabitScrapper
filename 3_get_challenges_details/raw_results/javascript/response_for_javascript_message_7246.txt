a["{\"msg\":\"result\",\"id\":\"2362\",\"result\":{\"_id\":\"q3LpnKujfvSZpu9qQ\",\"author\":\"Deep Xavier\",\"authorId\":\"a777e8chPvJkY3tKa\",\"code\":\"function bitwiseOneZero(arr) {\\n\\t// your recursive solution here\\n\\treturn bitwiseOneZero(arr)\\n}\",\"difficulty\":4.043478260869565,\"editorId\":\"a777e8chPvJkY3tKa\",\"familyId\":\"J2LKrRdbmCjQS94dd\",\"instructions\":\"Write a function that returns the smallest integer in an array with its corresponding index and its parity. Although these tasks can be equivocally achievable with the use of some built-in and Array functions, the purpose and intent of this challenge is for you to solve it recursively.\\n\\n### Output Structure\\n```\\n{\\\"@index \\\" + index_of_smallest: smallest_integer, \\\"parity\\\": \\\"odd|even\\\"}\\n```\\n\\n### Examples\\n```\\nbitwiseOneZero([107, 19, -18, -79, 36, 23, 97]) ➞ {\\\"@index 3\\\": -79, \\\"parity\\\": \\\"odd\\\"}\\n\\nbitwiseOneZero([31, 7, 2, 13, 7, 9, 10, 13]) ➞ {\\\"@index 2\\\": 2, \\\"parity\\\": \\\"even\\\"}\\n\\nbitwiseOneZero([3, 3, 3, 3, 3, 3]) ➞ {\\\"@index 0\\\": 3, \\\"parity\\\": \\\"odd\\\"}\\n```\\n\\n### Notes\\n- The use of `indexOf()` and `min()` are restricted.\\n- You can read more about recursion (see **Resources** tab) if you aren't familiar with it or haven't fully understood the concept before taking up this challenge.\\n- If you think recursion is fun, you can find a collection of those challenges [here](https://edabit.com/collection/YJH4pAyqDbhLc4STc).\\n- Another version of this challenge which is non-recursive can be found [here](https://edabit.com/challenge/JCxa7DhzitMZFWBk4).\",\"isFree\":false,\"isHidden\":false,\"lab\":\"const noIndexOfMin = f => !RegExp('indexOf|min','gm').test(f)\\nconst nonRecur = f => (`${f}`.match(RegExp(`${f.name}`,'gm'))||[]).length > +(/function/.test(f))\\nTest.assertNotEquals(noIndexOfMin(bitwiseOneZero), false, \\\"min() and indexOf() functions aren't allowed!\\\")\\nTest.assertNotEquals(nonRecur(bitwiseOneZero), false, \\\"Recursion is required!\\\")\\n\\nlet numVector = [\\n  [107, 19, -18, -79, 36, 23, 97],\\n  [31, 7, 2, 13, 7, 9, 10, 13],\\n  [3, 3, 3, 3, 3, 3],\\n  [-31, -7, -13, -7, -9, -13],\\n  [1, 3, 9, 5, -1, 7, 9, 49],\\n  [63, 77, 13, 75, 91, 113],\\n  [6, 6, 6, 6, 6, 6]\\n],\\nresVector = [\\n  {\\\"@index 3\\\": -79, \\\"parity\\\": \\\"odd\\\"},\\n  {\\\"@index 2\\\": 2, \\\"parity\\\": \\\"even\\\"},\\n  {\\\"@index 0\\\": 3, \\\"parity\\\": \\\"odd\\\"},\\n  {\\\"@index 0\\\": -31, \\\"parity\\\": \\\"odd\\\"},\\n  {\\\"@index 4\\\": -1, \\\"parity\\\": \\\"odd\\\"},\\n  {\\\"@index 2\\\": 13, \\\"parity\\\": \\\"odd\\\"},\\n  {\\\"@index 0\\\": 6, \\\"parity\\\": \\\"even\\\"}]\\nfor (let i in numVector) Test.assertSimilar(bitwiseOneZero(numVector[i]), resVector[i])\",\"language\":\"javascript\",\"stats\":{\"completed\":{\"ratings\":[5,5,5,5,5,1,5,3,3,3,4,3,5,4,4,5,4,5,3,5,2,4,5],\"rators\":[\"yjtdwc2AC4jA2RWtn\",\"a777e8chPvJkY3tKa\",\"aEm3Wvj2rFYRL8Lrb\",\"mHT2bJb5SByfJ8yKS\",\"qvNk7pHSveLu3jqWw\",\"hcm8sL8mNJTSfTdgE\",\"va3fDAQm4sqSMoy3R\",\"buX4mCQhtXCfBjeno\",\"Es4eX2stRpyoXeC7f\",\"YEjnBpgNjDLhnf4H7\",\"DHGZgTxTdCZ2syhac\",\"DPi9QGLctq2y76KuE\",\"bXaGdBM8FBLHf7N6Y\",\"PH32cNxBjrK4a28sn\",\"tAF9Gf6PiGogbZuWs\",\"M4vq8ATaS9Jg5X7iP\",\"TtrXnGzi9MyhLvWiz\",\"8BJyXvRWcrvN3nttS\"],\"total\":20,\"quality\":[]},\"flags\":0},\"summary\":\"Write a function that returns the smallest integer in an array with its corresponding index and its parity. Although these tasks can be equivocally achievable with the use of some built-in and Array functions, the purpose and intent of this challenge is for you to solve it recursively.\\n\\nOutput Structure\\n{\\\"@index \\\" + indexofsmallest: smallest_integer, \\\"parity\\\":\",\"tags\":[\"recursion\",\"arrays\"],\"timestamp\":{\"$date\":1595755157675},\"title\":\"Recursion: Parity of the Smallest Integer\",\"quality\":0,\"family\":[{\"_id\":\"q3LpnKujfvSZpu9qQ\",\"language\":\"javascript\"},{\"_id\":\"GTnW4bQAZQ38oHuyi\",\"language\":\"python3\"}]}}"]