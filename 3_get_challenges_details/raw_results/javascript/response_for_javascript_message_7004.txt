a["{\"msg\":\"result\",\"id\":\"2244\",\"result\":{\"_id\":\"EthHvCiRXs8uzoGZJ\",\"author\":\"David Newman\",\"authorId\":\"Po3v3dHCk6wYGKMwi\",\"code\":\"// don't change this code\\nclass Node {\\n\\tconstructor(v) {\\n\\t\\tthis.val=v;\\n\\t\\tthis.next=null;\\n\\t}\\n}\\nclass LinkedList {\\n\\tconstructor(a) {\\n\\t\\tthis.head = null;\\n\\t\\tthis.tail = null;\\n\\t\\tif(!!a){\\n\\t\\t\\ta.forEach(v=> {\\n\\t\\t\\t\\tthis.insertTail(v);\\n\\t\\t\\t})\\n\\t\\t}\\n\\t}\\n\\tinsertHead(v) {\\n\\t\\tlet nn = new Node(v);\\n\\t\\tnn.next = this.head;\\n\\t\\tif(!this.tail) {\\n\\t\\t\\tthis.tail=nn;\\n\\t\\t}\\n\\t\\tthis.head=nn;\\n\\t}\\n\\tinsertTail(v) {\\n    if(!this.head) return this.insertHead(v);\\n\\t\\tlet nn = new Node(v);\\n\\t\\tthis.tail.next = nn;\\n\\t\\tthis.tail = nn;\\n\\t}\\n\\tprint() {\\n\\t\\tlet o=[],\\n\\t\\t\\t\\tnode = this.head;\\n\\t\\twhile(node){\\n\\t\\t\\to.push(node.val);\\n\\t\\t\\tnode=node.next\\n\\t\\t}\\n\\t\\treturn o;\\n\\t}\\n}\\n// okay, you can change stuff below this line. Have fun!\\n\\nfunction reverse(linklist) {\\n\\t// your stuff goes here (or create your own prototype method)\\n}\",\"difficulty\":3.5,\"editorId\":\"Po3v3dHCk6wYGKMwi\",\"familyId\":\"6oenXP9rs5CA6GNfB\",\"instructions\":\"A **linked list** is a special type of data structure where a given item in the list - called a *node* - has one or two pointers to other nodes in the list. The linked list is either:\\n\\n - **Singly-Linked**: Each node points to the next node in the list only, but not back to the previous node.\\n - **Doubly-Linked**: Each node points to both the next node *and* the previous node.\\n\\nFor example, consider the **singly-linked list** represented by the array `[1, 2, 3, 4]`\\n\\n ```\\n  1 --> 2--> 3 --> 4\\n ```\\n\\n Note that from node 3, for example, you can follow its pointer to node 4, but you *cannot travel from node 3 back to node 2*!\\n\\n ```\\n  ... 2 <-x- 3\\n ```\\n\\nBecause there is no pointer from node 3 to node 2, 3 is \\\"unaware\\\" of its previous node (node 2).\\n\\n**Reverse a linked list.**\\n\\nTo get the Super Mega Awesome Challenge prize (not really), you must also do the following:\\n\\n1. Reverse the list *in place*. For you CS types, that means O(1) auxiliary space. For you non-CS types, imagine that you do *not* have much extra space to store another \\\"copy\\\" of your linked list.\\n\\n2. Use a prototype method added to the included LinkedList class. If you *do* include a prototype method, note that this will take precedence over any \\\"non-prototype\\\" methods!\\n\\n_Note that not doing these will still pass the challenge: these just earn extra coolness points!_\\n\\nFinally, please note that you **_MUST_** return the reversed linked list at the end of the function (however you do it!)\\n\\n### Examples\\n```\\n[1, 2, 3, 4] ➞ [4, 3, 2, 1]\\n\\n[8, 6, 7, 5, 3, 0, 9] ➞ [9, 0, 3, 5, 7, 6, 8]\\n\\n[\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"e\\\"] ➞ [\\\"e\\\" ,\\\"c\\\", \\\"b\\\", \\\"a\\\"]\\n```\\n\\n### Tips\\n - Your initial linked list will be created with `new LinkedList(arr)`, where `arr` is a list of items such as `[1,2,3,4]`.\\n - The linked list has three helper methods\\n    - `insertHead(v)`: Inserts a new node with value `v` at the head of the list.\\n    - `insertTail(v)`: Inserts a new node with value `v` at the tail of the list.\\n    - `print()`: Traverses the list (head to tail), pushes each value into an array, returns the array.\\n - It also has two default properties:\\n    - `head`: the current head of the list. Default null. \\n    - `tail`: the default tail of the list. Default null. Note that if the list is exactly one node long, the tail will equal the head!\\n - Generally speaking, if you're doing the reversing *in place*, you'll need to figure out a way to \\\"reverse\\\" those one-way pointers.\",\"isFree\":false,\"isHidden\":false,\"lab\":\"const LLCands = [{\\n    val: [1, 2, 3, 4],\\n    msg:'A simple Linked List'\\n}, {\\n    val: [8, 6, 7, 5, 3, 0, 9],\\n    msg: 'A slightly more complicated list'\\n}, {\\n    val: [1, 1, 3, 8],\\n    msg:'The code is strong with this one'\\n}, {\\n    val: ['a', 'b', 'c', 'e'],\\n    msg:'Letters should work!'\\n}, {\\n    val: ['r', 'a', 'c', 'e', 'c','a', 'r'],\\n    msg: 'Palindromes are pretty fun too...'\\n}, {\\n    val: Array(20).fill(1).map(q => Math.floor(Math.random() * 99)),\\n    msg:'Even a random array works!'\\n}], \\n\\t\\t\\tfs = require('fs'),\\n\\t\\t\\tcodeLocked = `//Don't change this code! Don't do it!\\nclass Node{\\n\\tconstructor(v){\\n\\t\\tthis.val=v;\\n\\t\\tthis.next=null;\\n\\t}\\n}\\nclass LinkedList{\\n\\tconstructor(a){\\n\\t\\tthis.head = null;\\n\\t\\tthis.tail=null;\\n\\t\\tif(!!a){\\n\\t\\t\\ta.forEach(v=>{\\n\\t\\t\\t\\tthis.insertTail(v);\\n\\t\\t\\t})\\n\\t\\t}\\n\\t}\\n\\tinsertHead(v){\\n\\t\\tlet nn = new Node(v);\\n\\t\\tnn.next = this.head;\\n\\t\\tif(!this.tail){\\n\\t\\t\\tthis.tail=nn;\\n\\t\\t}\\n\\t\\tthis.head=nn;\\n\\t}\\n\\tinsertTail(v){\\n    if(!this.head) return this.insertHead(v);\\n\\t\\tlet nn = new Node(v);\\n\\t\\tthis.tail.next = nn;\\n\\t\\tthis.tail = nn;\\n\\t}\\n\\tprint(){\\n\\t\\tlet o=[],\\n\\t\\t\\t\\tnode = this.head;\\n\\t\\twhile(node){\\n\\t\\t\\to.push(node.val);\\n\\t\\t\\tnode=node.next\\n\\t\\t}\\n\\t\\treturn o;\\n\\t}\\n}\\n//Okay, you can change stuff below this line. Have fun!`;//to check if user changed the \\\"don't change me!\\\" code.\\nconst solOkay = fs.readFileSync('solution.txt','utf-8').startsWith(codeLocked);\\nconsole.log(`Did you not touch the \\\"don't touch me\\\" code?`)\\nTest.assertEquals(solOkay,true,\\\"You're not allowed to change text before the marked line!\\\",'potato');\\nif(!solOkay) return false;\\nconst proto = !!new LinkedList().reverse;\\nif (proto) {\\n    console.log('☺ Using Prototype Method: +1 Coolness Point!')\\n}\\nlet testLL = new LinkedList([1,2,3,4]);\\nif(((proto && testLL.reverse()) || (!proto && reverse(testLL))) && testLL.print().toString()==\\\"4,3,2,1\\\"){\\n\\t\\tconsole.log('☺ List reversed in place: +1 Coolness Point!')\\n}\\nLLCands.forEach(l => {\\n    let candLL = new LinkedList(l.val),\\n        reversedLL = candLL.print().reverse();\\n\\t\\tconsole.log(' ')\\n    console.log(':--- ⛓: '+ l.msg+' ---:')\\n\\t\\tconsole.log(`Reverse: ${l.val}`)\\n\\t\\tif((!!proto && !(candLL.reverse() instanceof LinkedList)) || (!proto && !(reverse(candLL) instanceof LinkedList))){\\n            Test.assertEquals(false, true, 'Hey! Your reversed linked list must still be a linked list!')\\n            return false;\\n\\t\\t}\\n    if (proto) {\\n        Test.assertSimilar(candLL.reverse().print(), reversedLL, `${candLL.print()} reversed is ${reversedLL}, but you said ${candLL.reverse().print()}!`)\\n    } else {\\n        Test.assertSimilar(reverse(candLL).print(), reversedLL, `${candLL.print()} reversed is ${reversedLL}, but you said ${reverse(candLL).print()}!`)\\n    }\\n})\",\"language\":\"javascript\",\"quality\":0,\"stats\":{\"completed\":{\"ratings\":[4,4,4,4,4,4,3,0,5,3],\"quality\":[],\"rators\":[\"Po3v3dHCk6wYGKMwi\",\"yjtdwc2AC4jA2RWtn\",\"h4jFmtbFn92eA4649\",\"PRd3ZE6vHgzsezF7z\",\"aEm3Wvj2rFYRL8Lrb\"],\"total\":5},\"flags\":0},\"summary\":\"A linked list is a special type of data structure where a given item in the list - called a node - has one or two pointers to other nodes in the list. The linked list is either:\\n\\n Singly-Linked: Each node points to the next node in the list only, but not back to the previous node.\\n Doubly-Linked: Each node points to both the next node and the previous node.\\n\\nF\",\"tags\":[\"data_structures\",\"recursion\",\"higher_order_functions\"],\"timestamp\":{\"$date\":1602968187846},\"title\":\"Reverse a Linked List\",\"family\":[{\"_id\":\"EthHvCiRXs8uzoGZJ\",\"language\":\"javascript\"}]}}"]