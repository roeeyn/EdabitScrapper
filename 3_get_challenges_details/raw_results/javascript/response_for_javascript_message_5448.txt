a["{\"msg\":\"result\",\"id\":\"1476\",\"result\":{\"_id\":\"SxSLmEjtx2EBsEsm5\",\"author\":\"benmcl@shaw.ca\",\"authorId\":\"SYEuojZtP6yLXryHv\",\"code\":\"function binary(arr, n) {\\n\\t\\n}\",\"difficulty\":2.175,\"editorId\":\"BkPgkDQGHm66X4Qai\",\"familyId\":\"94vYfd7nKyFehBLFi\",\"instructions\":\"Binary search is the fastest method to search a sorted array.\\n\\nImagine you are an undercover agent and you're at a cocktail party hosted by the bad guys. You sneak into the drug lord's office looking for an important document. Fortunately, the drug lord has organized his files by number from lowest to highest. You know the number of the file you are looking for is 3412. Since there are thousands of files and you have very limited time you wouldn't start at 0 and check each one. This would be the iterative approach. Instead, you would look halfway through the stack and see what number it is, if it's less than 3412 you know that everything below it won't contain the file for so you discard the bottom pile and search the top. Each time looking in the middle and discarding the half that won't contain the number you are looking for. This is a binary search.\\n\\nYour challenge is to write a function that searches a sorted array and returns the index of the number you are searching for.\\n\\n\\\"BUT WAIT!!!\\\" you say...\\n\\n\\\"Why don't I just used `findIndex`, or `indexOf` to get the index?\\\" you ask.\\n\\nBecause both of those are iterative. They have a time complexity of O(n), in our spy scenario that is too long,  they will find you searching the files and you'll go swimming with the fishes. The binary search has a time complexity of O(logN). Meaning it is substantially faster.\\n\\n### Arguments\\n- `Array`: The array over which you searching.\\n- `Number`: The number whose index you want to return.\\n- Returns `Index` || `-1`: If the number is found the index is returned, otherwise it returns `-1`.\\n\\n### Examples\\n```\\nbinary([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ➞ 2\\n\\nbinary([11, 12, 21, 23, 40, 40, 42, 43, 54, 57, 92] ➞ 31\\n\\nbinary([11, 12, 21, 23, 40, 40, 42, 43, 54, 57, 92] ➞ 40\\n```\\n\\n### Notes\\n- This is part of my Data Structures series. A collection of common coding interview challenges used to test one's understanding of data structures.\\n- This entire series of challenges can be found [here](https://edabit.com/collection/hqZyMk9NnHGJBnpTB).\",\"isFree\":false,\"isHidden\":false,\"lab\":\"const noArrayMethods = (f) => /(findIndex)|(indexOf)/g.test(f.toString())\\nTest.assertNotEquals(noArrayMethods(binary), true, \\\"Please don't use array prototype methods\\\")\\n\\nTest.assertSimilar(binary([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2), 2)\\nTest.assertSimilar(\\n  binary([176, 188, 199, 200, 210, 222, 1, 10, 20, 47, 59, 63, 75, 88, 99, 107, 120, 133, 155, 162], 107),\\n  15\\n)\\nTest.assertSimilar(binary([1, 1, 1, 3, 3, 5, 6, 7, 8, 9], 5), 5)\\nTest.assertSimilar(binary([1, 3, 3, 4, 4, 6, 6, 7, 7, 9], 8), -1)\\nTest.assertSimilar(binary([0, 1, 2, 3, 4, 5, 6, 7, 9], 6), 6)\\nTest.assertSimilar(\\n  binary([10, 17, 21, 27, 31, 32, 4, 42, 44, 45, 55, 57, 57, 60, 69, 72, 74, 79, 88, 89, 91, 96], 44),\\n  8\\n)\\nTest.assertSimilar(binary([11, 12, 21, 23, 40, 40, 42, 43, 54, 57, 92], 31), -1)\\nTest.assertSimilar(\\n  binary([16, 18, 24, 27, 3, 33, 45, 5, 51, 52, 57, 67, 70, 71, 72, 77, 8, 80, 83, 87, 93, 99], 80),\\n  17\\n)\\nTest.assertSimilar(\\n  binary([11, 13, 17, 19, 22, 23, 25, 36, 39, 39, 40, 46, 48, 51, 56, 77, 82, 83, 87, 89, 91, 98], 89),\\n  19\\n)\\nTest.assertSimilar(\\n  binary([11, 18, 27, 32, 36, 39, 42, 48, 58, 6, 6, 60, 64, 67, 67, 74, 77, 82, 88, 89, 92, 95], 37),\\n  -1\\n)\\nTest.assertSimilar(\\n  binary([16, 23, 31, 35, 48, 56, 6, 66, 68, 69, 80, 82, 82, 86, 9, 91, 92, 93, 94, 96, 97, 99], 59),\\n  -1\\n)\\nTest.assertSimilar(\\n  binary([10, 13, 2, 22, 25, 27, 43, 44, 46, 47, 47, 51, 69, 78, 79, 83, 85, 85, 86, 90, 96, 98, 99], 54),\\n  -1\\n)\\nTest.assertSimilar(binary([0, 1, 2, 3, 4, 5, 6, 7, 9], 2), 2)\",\"language\":\"javascript\",\"quality\":0,\"stats\":{\"completed\":{\"ratings\":[2,2,2,2,2,0,3,3,1,0,1,2,3,2,3,3,3,3,1,4,1,3,3,2,0,3,1,3,3,3,1,3,2,3,0,3,5,1,2,3],\"quality\":[],\"rators\":[\"k6QB6fzbj4LsWktRL\",\"SYEuojZtP6yLXryHv\",\"RtPhDuwmvWNHiBxmG\",\"yuLxi2qBJvMnwgdgJ\",\"cp3X8hk8yNME7qoD9\",\"CNc6rmwhbxkxEhHAp\",\"Ya3eHgs8x3unZRLpb\",\"QRv96jmNaYsWkxQEG\",\"PGCDJpQMN8Sjn9Gm6\",\"Yp7uvStL97cC9fKkY\",\"LwwQoT3e8c7MqZ9Kn\",\"LFSASkxgw9hr3KqmC\",\"pFo4dga9BMj58Cc4B\",\"yjtdwc2AC4jA2RWtn\",\"FJsvM5yqKuK9yMk9P\",\"zMCXYFZSsviDCvjnY\",\"AQSqD9oNv2uPfxZCR\",\"bX6tpTCjwoi6XMMbK\",\"pBPeMTaRmdFWQezW3\",\"QHGf82dezRbj9HTNr\",\"Xk2g4CNFAnYcvxiSr\",\"RxPZwEqL73Hz5iACx\",\"65dbBZynphj53nXqA\",\"j5FSQCayX3By73CCw\",\"2Qk2mFu9HBFzrB24i\",\"PH32cNxBjrK4a28sn\",\"mXN5uqD6Xa3fiKDKk\",\"oyB4Wr4EeZnoDaa8B\",\"AMpQSjKsRqhCDyS2j\",\"MvTcq3STHTCdusSXF\",\"TtrXnGzi9MyhLvWiz\",\"jyoLggHk8xQKZuoQC\",\"nw3rZ4ap8trEDtPRX\",\"3E2rmyzZBrw3QmmtF\",\"6vdn7gegY7xXxYCbe\"],\"total\":37},\"flags\":0},\"summary\":\"Binary search is the fastest method to search a sorted array.\\n\\nImagine you are an undercover agent and you're at a cocktail party hosted by the bad guys. You sneak into the drug lord's office looking for an important document. Fortunately, the drug lord has organized his files by number from lowest to highest. You know the number of the file you are looking fo\",\"tags\":[\"algorithms\",\"arrays\",\"data_structures\",\"interview\"],\"timestamp\":{\"$date\":1615477191468},\"title\":\"Data Structures (2): Binary Search\",\"family\":[{\"_id\":\"SxSLmEjtx2EBsEsm5\",\"language\":\"javascript\"}]}}"]